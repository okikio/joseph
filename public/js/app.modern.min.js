function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

var DOCUMENT_NODE_TYPE = 9;
/**
 * A polyfill for Element.matches()
 */

if (typeof Element !== 'undefined' && !Element.prototype.matches) {
  var proto = Element.prototype;
  proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
}
/**
 * Finds the closest parent that matches a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @return {Function}
 */


function closest(element, selector) {
  while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
    if (typeof element.matches === 'function' && element.matches(selector)) {
      return element;
    }

    element = element.parentNode;
  }
}

var closest_1 = closest;

/**
 * Delegates event to a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @param {Boolean} useCapture
 * @return {Object}
 */

function delegate(element, selector, type, callback, useCapture) {
  var listenerFn = listener.apply(this, arguments);
  element.addEventListener(type, listenerFn, useCapture);
  return {
    destroy: function () {
      element.removeEventListener(type, listenerFn, useCapture);
    }
  };
}
/**
 * Finds closest match and invokes callback.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @return {Function}
 */


function listener(element, selector, type, callback) {
  return function (e) {
    e.delegateTarget = closest_1(e.target, selector);

    if (e.delegateTarget) {
      callback.call(element, e);
    }
  };
}

var delegate_1 = delegate;

var Cache_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Cache = exports.Cache = function () {
    function Cache() {
      _classCallCheck(this, Cache);

      this.pages = {};
      this.last = null;
    }

    _createClass(Cache, [{
      key: 'cacheUrl',
      value: function cacheUrl(page) {
        if (page.url in this.pages === false) {
          this.pages[page.url] = page;
        }

        this.last = this.pages[page.url];
        this.swup.log('Cache (' + Object.keys(this.pages).length + ')', this.pages);
      }
    }, {
      key: 'getPage',
      value: function getPage(url) {
        return this.pages[url];
      }
    }, {
      key: 'getCurrentPage',
      value: function getCurrentPage() {
        return this.getPage(window.location.pathname + window.location.search);
      }
    }, {
      key: 'exists',
      value: function exists(url) {
        return url in this.pages;
      }
    }, {
      key: 'empty',
      value: function empty() {
        this.pages = {};
        this.last = null;
        this.swup.log('Cache cleared');
      }
    }, {
      key: 'remove',
      value: function remove(url) {
        delete this.pages[url];
      }
    }]);

    return Cache;
  }();

  exports.default = Cache;
});
unwrapExports(Cache_1);
var Cache_2 = Cache_1.Cache;

var classify_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var classify = function classify(text) {
    var output = text.toString().toLowerCase().replace(/\s+/g, '-') // Replace spaces with -
    .replace(/\//g, '-') // Replace / with -
    .replace(/[^\w\-]+/g, '') // Remove all non-word chars
    .replace(/\-\-+/g, '-') // Replace multiple - with single -
    .replace(/^-+/, '') // Trim - from start of text
    .replace(/-+$/, ''); // Trim - from end of text

    if (output[0] === '/') output = output.splice(1);
    if (output === '') output = 'homepage';
    return output;
  };

  exports.default = classify;
});
unwrapExports(classify_1);

var createHistoryRecord_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var createHistoryRecord = function createHistoryRecord(url) {
    window.history.pushState({
      url: url || window.location.href.split(window.location.hostname)[1],
      random: Math.random(),
      source: 'swup'
    }, document.getElementsByTagName('title')[0].innerText, url || window.location.href.split(window.location.hostname)[1]);
  };

  exports.default = createHistoryRecord;
});
unwrapExports(createHistoryRecord_1);

var utils = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var query = exports.query = function query(selector) {
    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;

    if (typeof selector !== 'string') {
      return selector;
    }

    return context.querySelector(selector);
  };

  var queryAll = exports.queryAll = function queryAll(selector) {
    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;

    if (typeof selector !== 'string') {
      return selector;
    }

    return Array.prototype.slice.call(context.querySelectorAll(selector));
  };
});
unwrapExports(utils);
var utils_1 = utils.query;
var utils_2 = utils.queryAll;

var getDataFromHtml_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var getDataFromHtml = function getDataFromHtml(html, containers) {
    var content = html.replace('<body', '<div id="swupBody"').replace('</body>', '</div>');
    var fakeDom = document.createElement('div');
    fakeDom.innerHTML = content;
    var blocks = [];

    var _loop = function _loop(i) {
      if (fakeDom.querySelector(containers[i]) == null) {
        // page in invalid
        return {
          v: null
        };
      } else {
        (0, utils.queryAll)(containers[i]).forEach(function (item, index) {
          (0, utils.queryAll)(containers[i], fakeDom)[index].setAttribute('data-swup', blocks.length); // marks element with data-swup

          blocks.push((0, utils.queryAll)(containers[i], fakeDom)[index].outerHTML);
        });
      }
    };

    for (var i = 0; i < containers.length; i++) {
      var _ret = _loop(i);

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }

    var json = {
      title: fakeDom.querySelector('title').innerText,
      pageClass: fakeDom.querySelector('#swupBody').className,
      originalContent: html,
      blocks: blocks
    }; // to prevent memory leaks

    fakeDom.innerHTML = '';
    fakeDom = null;
    return json;
  };

  exports.default = getDataFromHtml;
});
unwrapExports(getDataFromHtml_1);

var fetch_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var fetch = function fetch(setOptions) {
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var defaults = {
      url: window.location.pathname + window.location.search,
      method: 'GET',
      data: null,
      headers: {}
    };

    var options = _extends({}, defaults, setOptions);

    var request = new XMLHttpRequest();

    request.onreadystatechange = function () {
      if (request.readyState === 4) {
        if (request.status !== 500) {
          callback(request);
        } else {
          callback(request);
        }
      }
    };

    request.open(options.method, options.url, true);
    Object.keys(options.headers).forEach(function (key) {
      request.setRequestHeader(key, options.headers[key]);
    });
    request.send(options.data);
    return request;
  };

  exports.default = fetch;
});
unwrapExports(fetch_1);

var transitionEnd_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var transitionEnd = function transitionEnd() {
    var el = document.createElement('div');
    var transEndEventNames = {
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'transitionend',
      OTransition: 'oTransitionEnd otransitionend',
      transition: 'transitionend'
    };

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return transEndEventNames[name];
      }
    }

    return false;
  };

  exports.default = transitionEnd;
});
unwrapExports(transitionEnd_1);

var getCurrentUrl_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var getCurrentUrl = function getCurrentUrl() {
    return window.location.pathname + window.location.search;
  };

  exports.default = getCurrentUrl;
});
unwrapExports(getCurrentUrl_1);

var markSwupElements_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var markSwupElements = function markSwupElements(element, containers) {
    var blocks = 0;

    var _loop = function _loop(i) {
      if (element.querySelector(containers[i]) == null) {
        console.warn('Element ' + containers[i] + ' is not in current page.');
      } else {
        (0, utils.queryAll)(containers[i]).forEach(function (item, index) {
          (0, utils.queryAll)(containers[i], element)[index].setAttribute('data-swup', blocks);
          blocks++;
        });
      }
    };

    for (var i = 0; i < containers.length; i++) {
      _loop(i);
    }
  };

  exports.default = markSwupElements;
});
unwrapExports(markSwupElements_1);

var Link_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Link = function () {
    function Link(elementOrUrl) {
      _classCallCheck(this, Link);

      if (elementOrUrl instanceof Element || elementOrUrl instanceof SVGElement) {
        this.link = elementOrUrl;
      } else {
        this.link = document.createElement('a');
        this.link.href = elementOrUrl;
      }
    }

    _createClass(Link, [{
      key: 'getPath',
      value: function getPath() {
        var path = this.link.pathname;

        if (path[0] !== '/') {
          path = '/' + path;
        }

        return path;
      }
    }, {
      key: 'getAddress',
      value: function getAddress() {
        var path = this.link.pathname + this.link.search;

        if (this.link.getAttribute('xlink:href')) {
          path = this.link.getAttribute('xlink:href');
        }

        if (path[0] !== '/') {
          path = '/' + path;
        }

        return path;
      }
    }, {
      key: 'getHash',
      value: function getHash() {
        return this.link.hash;
      }
    }]);

    return Link;
  }();

  exports.default = Link;
});
unwrapExports(Link_1);

var helpers = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Link = exports.markSwupElements = exports.getCurrentUrl = exports.transitionEnd = exports.fetch = exports.getDataFromHtml = exports.createHistoryRecord = exports.classify = undefined;

  var _classify2 = _interopRequireDefault(classify_1);

  var _createHistoryRecord2 = _interopRequireDefault(createHistoryRecord_1);

  var _getDataFromHtml2 = _interopRequireDefault(getDataFromHtml_1);

  var _fetch2 = _interopRequireDefault(fetch_1);

  var _transitionEnd2 = _interopRequireDefault(transitionEnd_1);

  var _getCurrentUrl2 = _interopRequireDefault(getCurrentUrl_1);

  var _markSwupElements2 = _interopRequireDefault(markSwupElements_1);

  var _Link2 = _interopRequireDefault(Link_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var classify = exports.classify = _classify2.default;
  var createHistoryRecord = exports.createHistoryRecord = _createHistoryRecord2.default;
  var getDataFromHtml = exports.getDataFromHtml = _getDataFromHtml2.default;
  var fetch = exports.fetch = _fetch2.default;
  var transitionEnd = exports.transitionEnd = _transitionEnd2.default;
  var getCurrentUrl = exports.getCurrentUrl = _getCurrentUrl2.default;
  var markSwupElements = exports.markSwupElements = _markSwupElements2.default;
  var Link = exports.Link = _Link2.default;
});
unwrapExports(helpers);
var helpers_1 = helpers.Link;
var helpers_2 = helpers.markSwupElements;
var helpers_3 = helpers.getCurrentUrl;
var helpers_4 = helpers.transitionEnd;
var helpers_5 = helpers.fetch;
var helpers_6 = helpers.getDataFromHtml;
var helpers_7 = helpers.createHistoryRecord;
var helpers_8 = helpers.classify;

var loadPage_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var loadPage = function loadPage(data, popstate) {
    var _this = this; // create array for storing animation promises


    var animationPromises = [],
        xhrPromise = void 0;

    var animateOut = function animateOut() {
      _this.triggerEvent('animationOutStart'); // handle classes


      document.documentElement.classList.add('is-changing');
      document.documentElement.classList.add('is-leaving');
      document.documentElement.classList.add('is-animating');

      if (popstate) {
        document.documentElement.classList.add('is-popstate');
      }

      document.documentElement.classList.add('to-' + (0, helpers.classify)(data.url)); // animation promise stuff

      animationPromises = _this.getAnimationPromises('out');
      Promise.all(animationPromises).then(function () {
        _this.triggerEvent('animationOutDone');
      }); // create history record if this is not a popstate call

      if (!popstate) {
        // create pop element with or without anchor
        var state = void 0;

        if (_this.scrollToElement != null) {
          state = data.url + _this.scrollToElement;
        } else {
          state = data.url;
        }

        (0, helpers.createHistoryRecord)(state);
      }
    };

    this.triggerEvent('transitionStart', popstate); // set transition object

    if (data.customTransition != null) {
      this.updateTransition(window.location.pathname, data.url, data.customTransition);
      document.documentElement.classList.add('to-' + (0, helpers.classify)(data.customTransition));
    } else {
      this.updateTransition(window.location.pathname, data.url);
    } // start/skip animation


    if (!popstate || this.options.animateHistoryBrowsing) {
      animateOut();
    } else {
      this.triggerEvent('animationSkipped');
    } // start/skip loading of page


    if (this.cache.exists(data.url)) {
      xhrPromise = new Promise(function (resolve) {
        resolve();
      });
      this.triggerEvent('pageRetrievedFromCache');
    } else {
      if (!this.preloadPromise || this.preloadPromise.route != data.url) {
        xhrPromise = new Promise(function (resolve, reject) {
          (0, helpers.fetch)(_extends({}, data, {
            headers: _this.options.requestHeaders
          }), function (response) {
            if (response.status === 500) {
              _this.triggerEvent('serverError');

              reject(data.url);
              return;
            } else {
              // get json data
              var page = _this.getPageData(response);

              if (page != null) {
                page.url = data.url;
              } else {
                reject(data.url);
                return;
              } // render page


              _this.cache.cacheUrl(page);

              _this.triggerEvent('pageLoaded');
            }

            resolve();
          });
        });
      } else {
        xhrPromise = this.preloadPromise;
      }
    } // when everything is ready, handle the outcome


    Promise.all(animationPromises.concat([xhrPromise])).then(function () {
      // render page
      _this.renderPage(_this.cache.getPage(data.url), popstate);

      _this.preloadPromise = null;
    }).catch(function (errorUrl) {
      // rewrite the skipPopStateHandling function to redirect manually when the history.go is processed
      _this.options.skipPopStateHandling = function () {
        window.location = errorUrl;
        return true;
      }; // go back to the actual page were still at


      window.history.go(-1);
    });
  };

  exports.default = loadPage;
});
unwrapExports(loadPage_1);

var renderPage_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var renderPage = function renderPage(page, popstate) {
    var _this = this;

    document.documentElement.classList.remove('is-leaving'); // replace state in case the url was redirected

    var link = new helpers.Link(page.responseURL);

    if (window.location.pathname !== link.getPath()) {
      window.history.replaceState({
        url: link.getPath(),
        random: Math.random(),
        source: 'swup'
      }, document.title, link.getPath()); // save new record for redirected url

      this.cache.cacheUrl(_extends({}, page, {
        url: link.getPath()
      }));
    } // only add for non-popstate transitions


    if (!popstate || this.options.animateHistoryBrowsing) {
      document.documentElement.classList.add('is-rendering');
    }

    this.triggerEvent('willReplaceContent', popstate); // replace blocks

    for (var i = 0; i < page.blocks.length; i++) {
      document.body.querySelector('[data-swup="' + i + '"]').outerHTML = page.blocks[i];
    } // set title


    document.title = page.title;
    this.triggerEvent('contentReplaced', popstate);
    this.triggerEvent('pageView', popstate); // empty cache if it's disabled (because pages could be preloaded and stuff)

    if (!this.options.cache) {
      this.cache.empty();
    } // start animation IN


    setTimeout(function () {
      if (!popstate || _this.options.animateHistoryBrowsing) {
        _this.triggerEvent('animationInStart');

        document.documentElement.classList.remove('is-animating');
      }
    }, 10); // handle end of animation

    var animationPromises = this.getAnimationPromises('in');

    if (!popstate || this.options.animateHistoryBrowsing) {
      Promise.all(animationPromises).then(function () {
        _this.triggerEvent('animationInDone');

        _this.triggerEvent('transitionEnd', popstate); // remove "to-{page}" classes


        document.documentElement.className.split(' ').forEach(function (classItem) {
          if (new RegExp('^to-').test(classItem) || classItem === 'is-changing' || classItem === 'is-rendering' || classItem === 'is-popstate') {
            document.documentElement.classList.remove(classItem);
          }
        });
      });
    } else {
      this.triggerEvent('transitionEnd', popstate);
    } // reset scroll-to element


    this.scrollToElement = null;
  };

  exports.default = renderPage;
});
unwrapExports(renderPage_1);

var triggerEvent_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var triggerEvent = function triggerEvent(eventName, originalEvent) {
    // call saved handlers with "on" method and pass originalEvent object if available
    this._handlers[eventName].forEach(function (handler) {
      try {
        handler(originalEvent);
      } catch (error) {
        console.error(error);
      }
    }); // trigger event on document with prefix "swup:"


    var event = new CustomEvent('swup:' + eventName, {
      detail: eventName
    });
    document.dispatchEvent(event);
  };

  exports.default = triggerEvent;
});
unwrapExports(triggerEvent_1);

var on_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var on = function on(event, handler) {
    if (this._handlers[event]) {
      this._handlers[event].push(handler);
    } else {
      console.warn("Unsupported event " + event + ".");
    }
  };

  exports.default = on;
});
unwrapExports(on_1);

var off_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var off = function off(event, handler) {
    var _this = this;

    if (event != null) {
      if (handler != null) {
        if (this._handlers[event] && this._handlers[event].filter(function (savedHandler) {
          return savedHandler === handler;
        }).length) {
          var toRemove = this._handlers[event].filter(function (savedHandler) {
            return savedHandler === handler;
          })[0];

          var index = this._handlers[event].indexOf(toRemove);

          if (index > -1) {
            this._handlers[event].splice(index, 1);
          }
        } else {
          console.warn("Handler for event '" + event + "' no found.");
        }
      } else {
        this._handlers[event] = [];
      }
    } else {
      Object.keys(this._handlers).forEach(function (keys) {
        _this._handlers[keys] = [];
      });
    }
  };

  exports.default = off;
});
unwrapExports(off_1);

var updateTransition_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var updateTransition = function updateTransition(from, to, custom) {
    // transition routes
    this.transition = {
      from: from,
      to: to,
      custom: custom
    };
  };

  exports.default = updateTransition;
});
unwrapExports(updateTransition_1);

var getAnimationPromises_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var getAnimationPromises = function getAnimationPromises() {
    var promises = [];
    var animatedElements = (0, utils.queryAll)(this.options.animationSelector);
    animatedElements.forEach(function (element) {
      var promise = new Promise(function (resolve) {
        element.addEventListener((0, helpers.transitionEnd)(), function (event) {
          if (element == event.target) {
            resolve();
          }
        });
      });
      promises.push(promise);
    });
    return promises;
  };

  exports.default = getAnimationPromises;
});
unwrapExports(getAnimationPromises_1);

var getPageData_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var getPageData = function getPageData(request) {
    // this method can be replaced in case other content than html is expected to be received from server
    // this function should always return {title, pageClass, originalContent, blocks, responseURL}
    // in case page has invalid structure - return null
    var html = request.responseText;
    var pageObject = (0, helpers.getDataFromHtml)(html, this.options.containers);

    if (pageObject) {
      pageObject.responseURL = request.responseURL ? request.responseURL : window.location.href;
    } else {
      console.warn('Received page is invalid.');
      return null;
    }

    return pageObject;
  };

  exports.default = getPageData;
});
unwrapExports(getPageData_1);

var plugins = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var use = exports.use = function use(plugin) {
    if (!plugin.isSwupPlugin) {
      console.warn('Not swup plugin instance ' + plugin + '.');
      return;
    }

    this.plugins.push(plugin);
    plugin.swup = this;

    if (typeof plugin._beforeMount === 'function') {
      plugin._beforeMount();
    }

    plugin.mount();
    return this.plugins;
  };

  var unuse = exports.unuse = function unuse(plugin) {
    var pluginReference = void 0;

    if (typeof plugin === 'string') {
      pluginReference = this.plugins.find(function (p) {
        return plugin === p.name;
      });
    } else {
      pluginReference = plugin;
    }

    if (!pluginReference) {
      console.warn('No such plugin.');
      return;
    }

    pluginReference.unmount();

    if (typeof pluginReference._afterUnmount === 'function') {
      pluginReference._afterUnmount();
    }

    var index = this.plugins.indexOf(pluginReference);
    this.plugins.splice(index, 1);
    return this.plugins;
  };

  var findPlugin = exports.findPlugin = function findPlugin(pluginName) {
    return this.plugins.find(function (p) {
      return pluginName === p.name;
    });
  };
});
unwrapExports(plugins);
var plugins_1 = plugins.use;
var plugins_2 = plugins.unuse;
var plugins_3 = plugins.findPlugin;

var lib = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }(); // modules


  var _delegate2 = _interopRequireDefault(delegate_1);

  var _Cache2 = _interopRequireDefault(Cache_1);

  var _loadPage2 = _interopRequireDefault(loadPage_1);

  var _renderPage2 = _interopRequireDefault(renderPage_1);

  var _triggerEvent2 = _interopRequireDefault(triggerEvent_1);

  var _on2 = _interopRequireDefault(on_1);

  var _off2 = _interopRequireDefault(off_1);

  var _updateTransition2 = _interopRequireDefault(updateTransition_1);

  var _getAnimationPromises2 = _interopRequireDefault(getAnimationPromises_1);

  var _getPageData2 = _interopRequireDefault(getPageData_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Swup = function () {
    function Swup(setOptions) {
      _classCallCheck(this, Swup); // default options


      var defaults = {
        animateHistoryBrowsing: false,
        animationSelector: '[class*="transition-"]',
        linkSelector: 'a[href^="' + window.location.origin + '"]:not([data-no-swup]), a[href^="/"]:not([data-no-swup]), a[href^="#"]:not([data-no-swup])',
        cache: true,
        containers: ['#swup'],
        requestHeaders: {
          'X-Requested-With': 'swup',
          Accept: 'text/html, application/xhtml+xml'
        },
        plugins: [],
        skipPopStateHandling: function skipPopStateHandling(event) {
          return !(event.state && event.state.source === 'swup');
        }
      }; // merge options

      var options = _extends({}, defaults, setOptions); // handler arrays


      this._handlers = {
        animationInDone: [],
        animationInStart: [],
        animationOutDone: [],
        animationOutStart: [],
        animationSkipped: [],
        clickLink: [],
        contentReplaced: [],
        disabled: [],
        enabled: [],
        openPageInNewTab: [],
        pageLoaded: [],
        pageRetrievedFromCache: [],
        pageView: [],
        popState: [],
        samePage: [],
        samePageWithHash: [],
        serverError: [],
        transitionStart: [],
        transitionEnd: [],
        willReplaceContent: []
      }; // variable for id of element to scroll to after render

      this.scrollToElement = null; // variable for promise used for preload, so no new loading of the same page starts while page is loading

      this.preloadPromise = null; // variable for save options

      this.options = options; // variable for plugins array

      this.plugins = []; // variable for current transition object

      this.transition = {}; // variable for keeping event listeners from "delegate"

      this.delegatedListeners = {}; // make modules accessible in instance

      this.cache = new _Cache2.default();
      this.cache.swup = this;
      this.loadPage = _loadPage2.default;
      this.renderPage = _renderPage2.default;
      this.triggerEvent = _triggerEvent2.default;
      this.on = _on2.default;
      this.off = _off2.default;
      this.updateTransition = _updateTransition2.default;
      this.getAnimationPromises = _getAnimationPromises2.default;
      this.getPageData = _getPageData2.default;

      this.log = function () {}; // here so it can be used by plugins


      this.use = plugins.use;
      this.unuse = plugins.unuse;
      this.findPlugin = plugins.findPlugin; // enable swup

      this.enable();
    }

    _createClass(Swup, [{
      key: 'enable',
      value: function enable() {
        var _this = this; // check for Promise support


        if (typeof Promise === 'undefined') {
          console.warn('Promise is not supported');
          return;
        } // add event listeners


        this.delegatedListeners.click = (0, _delegate2.default)(document, this.options.linkSelector, 'click', this.linkClickHandler.bind(this));
        window.addEventListener('popstate', this.popStateHandler.bind(this)); // initial save to cache

        var page = (0, helpers.getDataFromHtml)(document.documentElement.outerHTML, this.options.containers);
        page.url = page.responseURL = (0, helpers.getCurrentUrl)();

        if (this.options.cache) {
          this.cache.cacheUrl(page);
        } // mark swup blocks in html


        (0, helpers.markSwupElements)(document.documentElement, this.options.containers); // mount plugins

        this.options.plugins.forEach(function (plugin) {
          _this.use(plugin);
        }); // modify initial history record

        window.history.replaceState(Object.assign({}, window.history.state, {
          url: window.location.href,
          random: Math.random(),
          source: 'swup'
        }), document.title, window.location.href); // trigger enabled event

        this.triggerEvent('enabled'); // add swup-enabled class to html tag

        document.documentElement.classList.add('swup-enabled'); // trigger page view event

        this.triggerEvent('pageView');
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this2 = this; // remove delegated listeners


        this.delegatedListeners.click.destroy();
        this.delegatedListeners.mouseover.destroy(); // remove popstate listener

        window.removeEventListener('popstate', this.popStateHandler.bind(this)); // empty cache

        this.cache.empty(); // unmount plugins

        this.options.plugins.forEach(function (plugin) {
          _this2.unuse(plugin);
        }); // remove swup data atributes from blocks

        (0, utils.queryAll)('[data-swup]').forEach(function (element) {
          element.removeAttribute('data-swup');
        }); // remove handlers

        this.off(); // trigger disable event

        this.triggerEvent('disabled'); // remove swup-enabled class from html tag

        document.documentElement.classList.remove('swup-enabled');
      }
    }, {
      key: 'linkClickHandler',
      value: function linkClickHandler(event) {
        // no control key pressed
        if (!event.metaKey && !event.ctrlKey && !event.shiftKey && !event.altKey) {
          // index of pressed button needs to be checked because Firefox triggers click on all mouse buttons
          if (event.button === 0) {
            this.triggerEvent('clickLink', event);
            event.preventDefault();
            var link = new helpers.Link(event.delegateTarget);

            if (link.getAddress() == (0, helpers.getCurrentUrl)() || link.getAddress() == '') {
              // link to the same URL
              if (link.getHash() != '') {
                // link to the same URL with hash
                this.triggerEvent('samePageWithHash', event);
                var element = document.querySelector(link.getHash());

                if (element != null) {
                  history.replaceState({
                    url: link.getAddress() + link.getHash(),
                    random: Math.random(),
                    source: 'swup'
                  }, document.title, link.getAddress() + link.getHash());
                } else {
                  // referenced element not found
                  console.warn('Element for offset not found (' + link.getHash() + ')');
                }
              } else {
                // link to the same URL without hash
                this.triggerEvent('samePage', event);
              }
            } else {
              // link to different url
              if (link.getHash() != '') {
                this.scrollToElement = link.getHash();
              } // get custom transition from data


              var customTransition = event.delegateTarget.getAttribute('data-swup-transition'); // load page

              this.loadPage({
                url: link.getAddress(),
                customTransition: customTransition
              }, false);
            }
          }
        } else {
          // open in new tab (do nothing)
          this.triggerEvent('openPageInNewTab', event);
        }
      }
    }, {
      key: 'popStateHandler',
      value: function popStateHandler(event) {
        if (this.options.skipPopStateHandling(event)) return;
        var link = new helpers.Link(event.state ? event.state.url : window.location.pathname);

        if (link.getHash() !== '') {
          this.scrollToElement = link.getHash();
        } else {
          event.preventDefault();
        }

        this.triggerEvent('popState', event);
        this.loadPage({
          url: link.getAddress()
        }, event);
      }
    }]);

    return Swup;
  }();

  exports.default = Swup;
});
var swup = unwrapExports(lib);

// export const { assign, keys, values } = Object;
// export let { isArray, from, of } = Array;
const assign = Object.assign;
const keys = Object.keys;
const isArray = Array.isArray;

let _capital = val => val[0].toUpperCase() + val.slice(1); // Test the type of a value

let _is = (val, type) => typeof val === type; // Is Instance Of

let _isInst = (ctor, obj) => ctor instanceof obj;

let _type = type => {
  // Tweak of _is
  return val => _is(val, type);
};

assign(_is, {
  el: el => _isInst(el, Element) || _isInst(el, Document),

  arrlike(obj) {
    let len = _is(obj.length, "number") && obj.length;
    return len === 0 || len > 0 && len - 1 in obj;
  },

  num: val => !isNaN(val) && _type("number")(val),
  class: obj => obj && obj._method && obj._class,
  not: (type, ...args) => !_is[type](...args),
  doc: ctor => _isInst(ctor, Document),
  def: val => !_is(val, "undefined"),
  win: val => val && val.window,
  undef: _type("undefined"),
  bool: _type("boolean"),
  fn: _type("function"),
  str: _type("string"),
  obj: _type("object"),
  nul: v => v === null,
  inst: _isInst,
  arr: isArray,
  _type
});
/**
 * @param  {Function} fn
 * @param  {Array<any>} args
 * @param  {Object} ctxt
 */

let _fnval = (fn, args, ctxt) => {
  if (_is.not("fn", fn) || keys(fn.prototype || {}).length > 0) {
    return fn;
  }

  return fn.apply(ctxt, args);
};
let STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
let ARGUMENT_NAMES = /(?:^|,)\s*([^\s,=]+)/g; // Argument names

let _argNames = fn => {
  let fnStr = fn.toString().replace(STRIP_COMMENTS, '');
  let argsList = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')'));
  let result = argsList.match(ARGUMENT_NAMES),
      stripped = [];
  if (_is.nul(result)) return [];else {
    for (let i = 0; i < result.length; i++) {
      stripped.push(result[i].replace(/[\s,]/g, ''));
    }

    return stripped;
  }
}; // Get or set a value in an Object, based on it's path

let _matches = (ele, sel) => {
  if (_is.undef(ele)) return;
  let matchSel = ele.matches || ele.msMatchesSelector || ele.webkitMatchesSelector;
  if (matchSel) return matchSel.call(ele, sel);
}; // A more efficient `new` keyword that allows for arrays to be passed as arguments

/**
 * @function getReferenceKey
 *
 * @description
 * get the reference key for the circular value
 *
 * @param keys the keys to build the reference key from
 * @param cutoff the maximum number of keys to include
 * @returns the reference key
 */
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join('.') || '.';
}
/**
 * @function getCutoff
 *
 * @description
 * faster `Array.prototype.indexOf` implementation build for slicing / splicing
 *
 * @param array the array to match the value in
 * @param value the value to match
 * @returns the matching index, or -1
 */


function getCutoff(array, value) {
  var length = array.length;

  for (var index = 0; index < length; ++index) {
    if (array[index] === value) {
      return index + 1;
    }
  }

  return 0;
}
/**
 * @function createReplacer
 *
 * @description
 * create a replacer method that handles circular values
 *
 * @param [replacer] a custom replacer to use for non-circular values
 * @param [circularReplacer] a custom replacer to use for circular methods
 * @returns the value to stringify
 */


function createReplacer(replacer, circularReplacer) {
  var hasReplacer = typeof replacer === 'function';
  var hasCircularReplacer = typeof circularReplacer === 'function';
  var cache = [];
  var keys = [];
  return function replace(key, value) {
    if (typeof value === 'object') {
      if (cache.length) {
        var thisCutoff = getCutoff(cache, this);

        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }

        keys[keys.length] = key;
        var valueCutoff = getCutoff(cache, value);

        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : "[ref=" + getReferenceKey(keys, valueCutoff) + "]";
        }
      } else {
        cache[0] = value;
        keys[0] = key;
      }
    }

    return hasReplacer ? replacer.call(this, key, value) : value;
  };
}
/**
 * @function stringify
 *
 * @description
 * strinigifer that handles circular values
 *
 * @param the value to stringify
 * @param [replacer] a custom replacer function for handling standard values
 * @param [indent] the number of spaces to indent the output by
 * @param [circularReplacer] a custom replacer function for handling circular values
 * @returns the stringified output
 */


function stringify(value, replacer, indent, circularReplacer) {
  return JSON.stringify(value, createReplacer(replacer, circularReplacer), indent);
}

var index_esm = /*#__PURE__*/Object.freeze({
	'default': stringify
});

var stringify$1 = getCjsExportFromNamespace(index_esm);

let _stringify = obj => {
  let fns = [];
  let json = stringify$1(obj, (key, val) => {
    if (typeof val == "function") {
      fns.push(val.toString());
      return "_";
    }

    return val;
  }, 4);
  return json.replace(/"_"/g, () => fns.shift());
};

var stringify_1 = {
  stringify: stringify$1,
  _stringify
};
var stringify_3 = stringify_1._stringify;

const {
  readyState
} = document; // Test for passive support, based on [github.com/rafrex/detect-passive-events]

let passive = false,
    opts = {},
    noop = () => {};

opts = Object.defineProperty({}, "passive", {
  get: () => passive = {
    capture: false,
    passive: true
  }
});
window.addEventListener("PassiveEventTest", noop, opts);
window.removeEventListener("PassiveEventsTest", noop, opts);
class _event {
  constructor() {
    this._events = {}; // Event info.

    this._emit = []; // Store events set to be emitted
  } // Prepare the event


  _preEvent(evt) {
    if (!this._events[evt]) // List of event's
      {
        this._events[evt] = [];
      }

    return this._events[evt];
  } // Apply event as object


  _eventApp(callback, scope, event) {
    return {
      callback: callback,
      scope: scope,
      event: event
    };
  } // Add a listener for a given event


  on(evt, callback, scope) {
    let $EvtApp, $evt;

    if (_is.undef(evt)) {
      return;
    } // If there is no event break


    if (_is.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is.not("arr", evt) && _is.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array
    // Loop through the list of events


    keys(evt).forEach(function (key) {
      $evt = evt[key];

      if (_is.obj(evt) && _is.not("arr", evt)) {
        $EvtApp = this._eventApp($evt, callback || this, key);

        this._preEvent(key).push($EvtApp); // Set event list

      } else {
        $EvtApp = this._eventApp(callback, scope, $evt);

        this._preEvent($evt).push($EvtApp); // Set event list

      }
    }, this);
    return this;
  } // Call all function(s) within an event


  emit(evt, args, scope) {
    let $Evt,
        $args = args;

    if (_is.undef(evt)) {
      return;
    } // If there is no event break


    if (_is.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is.not("arr", evt)) {
      evt = [evt];
    } // Set evt to an array
    // Loop through the list of events


    evt.forEach(function ($evt) {
      $Evt = this._preEvent($evt);

      if (!this._emit.includes($evt)) {
        this._emit.push($evt);
      }

      $Evt.forEach(_evt => {
        $args = args;

        if (_argNames(_evt.callback)[0] === "$evt") {
          $args = [_evt, ...args];
        }

        _evt.callback.apply(_is.undef(_evt.scope) ? scope : _evt.scope, $args);
      }, this);
    }, this);
    return this;
  } // Removes a listener for a given event


  off(evt, callback, scope) {
    let $evt;

    if (_is.undef(evt)) {
      return;
    } // If there is no event break


    if (_is.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is.not("arr", evt) && _is.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array


    let _off = function ($evt, callback, scope) {
      let _Evt = this._preEvent($evt);

      if (callback) {
        let i,
            app = this._eventApp(callback, scope, $evt);

        _Evt.forEach((val, _i) => {
          if (stringify_3(val) === stringify_3(app)) {
            i = _i;
          }
        }, this);

        if (i > -1) {
          _Evt.splice(i, 1);
        }
      } else {
        delete this._events[$evt];
      }
    }.bind(this);

    keys(evt).forEach(function (key) {
      $evt = evt[key];

      if (_is.obj(evt) && _is.not("obj", evt)) {
        _off(key, $evt, scope);
      } else {
        _off($evt, callback, scope);
      }
    }, this);
    return this;
  } // Adds a one time event listener for a given event


  once(evt, callback, scope) {
    if (_is.undef(evt)) {
      return;
    } // If there is no event break


    if (_is.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is.not("arr", evt) && _is.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array


    let $Fn = function (...args) {
      this.off(evt, $Fn, scope);
      callback.apply(scope, args);
    };

    this.on(evt, $Fn, scope);
    return this;
  } // List's all listeners for a given event


  listeners(evt) {
    let $Evt = this._preEvent(evt);

    if (!$Evt.length) {
      return [];
    }

    return $Evt.map(val => val.callback);
  } // List's all listener values for a given event


  listenerValues(evt, ...args) {
    let $Evt = this._preEvent(evt);

    if (!$Evt.length) {
      return [];
    }

    return $Evt.map(val => val.callback.call(val.scope, ...args));
  } // Clear all events


  clear() {
    this._eventCount = 0;
    this._events = {};
    return this;
  } // Clear all events


  clearListeners(evt) {
    this._events[evt] = [];
    return this;
  } // Name of all event's


  get _names() {
    return Object.keys(this._events);
  } // Number of events


  get _eventCount() {
    return this._names.length;
  } // Alias for the `on` method


  add(...args) {
    return this.on(...args);
  }

  bind(...args) {
    return this.on(...args);
  } // Alias for the `off` method


  remove(...args) {
    return this.off(...args);
  }

  unbind(...args) {
    return this.off(...args);
  } // Alias for the `emit` method


  fire(...args) {
    return this.emit(...args);
  }

  trigger(...args) {
    return this.emit(...args);
  } // Alias for the `listeners` method


  callbacks(...args) {
    return this.listeners(...args);
  }

  static get nativeEvents() {
    return "ready load blur focus focusin focusout resize click scroll dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".replace(/\s+/g, " ").split(" ");
  }

  static applyNative(evt, el, ev, i, action = "addEventListener", delegate) {
    if (!ev.length) return;
    let useCapture;

    let _emit = _ev => e => {
      if (_is.str(delegate) && _matches(e.target, delegate)) evt.emit(_ev, [e, e.target, evt, i], e.target);else if (!_is.str(delegate)) evt.emit(_ev, [e, el, evt, i], el);
    };

    if (/ready|load/.test(ev)) {
      if (!/in/.test(readyState)) {
        _emit("ready load")();
      } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', _emit("ready load"));
      } else {
        document.attachEvent('onreadystatechange', e => {
          if (!/in/.test(readyState)) _emit("ready load")(e);
        });
      }
    } else {
      ev.split(" ").forEach(val => {
        useCapture = /blur|focus/.test(val);
        el[action](val, _emit(ev), ev === "scroll" ? passive : {
          useCapture
        });
      });
    }
  }

}

const {
  documentElement
} = document;
let Ele;
let tagRE = /^\s*<(\w+|!)[^>]*>/;
let {
  applyNative,
  nativeEvents
} = _event;
let tagExpandRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig;
let _cssNumber = ["column-count", "columns", "font-weight", "line-height", "opacity", "z-index", "zoom"];
let _qsa = (dom = document, sel) => {
  let classes;
  if (!_is.str(sel) && sel.length === 0) return [];

  if (/^(#?[\w-]+|\.[\w-.]+)$/.test(sel)) {
    switch (sel.charAt(0)) {
      case '#':
        return [dom.getElementById(sel.substr(1))];

      case '.':
        classes = sel.substr(1).replace(/\./g, ' ');
        return [...dom.getElementsByClassName(classes)];

      default:
        return [...dom.getElementsByTagName(sel)];
    }
  }

  return [...dom.querySelectorAll(sel)];
}; // Check if the parent node contains the given DOM node. Returns false if both are the same node.

let _contains = (parent, node) => {
  if (parent.contains) return parent !== node && parent.contains(node);

  while (node && (node = node.parentNode)) if (node === parent) return true;

  return false;
}; // Support the Element Object as an Array

let _toArr = val => _is.inst(val, Ele) ? val.toArray() : val;
let _concat = function (...args) {
  [].map.call(args, val => _toArr(val));
  return [].concat.apply(_toArr(this), args);
}; // Create a flat Array

let _flatten = arr => arr.length > 0 ? _concat.apply([], arr) : arr; // Map Objects

let _map = (obj, fn, ctxt) => {
  return _flatten([].map.call(obj, fn, ctxt).filter(item => _is.def(item)));
}; // Select all children of an element

let _children = el => {
  return 'children' in el ? [].slice.call(el.children) : _map(el.childNodes, node => {
    if (node.nodeType === 1) return node;
  });
}; // Class name cache


let _cache = {}; // Get the class name for an Element

let _getclass = function classNme(node, value) {
  let name = node.className || '';
  let svg = name && !_is.undef(name.baseVal);
  if (_is.undef(value)) return svg ? name.baseVal : name;
  svg ? name.baseVal = value : node.className = value;
}; // Class name RegExp


let _classRE = name => {
  return name in _cache ? _cache[name] : _cache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)');
}; // Create an Element List from a HTML string


let _createElem = html => {
  let dom, container;
  container = document.createElement('div');
  container.innerHTML = '' + html.replace(tagExpandRE, "<$1></$2>");
  dom = [].slice.call(container.childNodes);
  dom.forEach(el => {
    container.removeChild(el);
  });
  return dom;
}; // Element selector


let _elem = (sel, ctxt) => {
  if (_is.str(sel)) {
    sel = sel.trim();

    if (tagRE.test(sel)) {
      return _createElem(sel);
    } else {
      return _qsa(ctxt, sel);
    }
  } else if (_is.inst(sel, Ele)) {
    return sel.ele;
  } else if (_is.arr(sel) || _is.inst(sel, NodeList)) {
    return [...sel].filter(item => _is.def(item));
  } else if (_is.obj(sel) || _is.el(sel)) {
    return [sel];
  } else if (_is.fn(sel)) {
    new Ele(document).ready(sel);
  }

  return [];
}; // Traverse DOM Depth First


let traverseDF = (_node, fn, childType = "childNodes") => {
  let recurse; // This is a recurse and immediately-invoking function

  recurse = node => {
    // Step 2
    node[childType] && node[childType].forEach(recurse, node); // Step 3

    fn.call(node, node); // Step 4
  };

  recurse(_node); // Step 1
}; // Quickly filter nodes by a selector


let _filter = (nodes, sel) => !_is.def(sel) ? new Ele(nodes) : new Ele(nodes).filter(sel); // Select all the different values in an Array, based on underscorejs

let _uniq = arr => {
  return [].filter.call(arr, (val, idx) => arr.indexOf(val) === idx);
}; // Quickly set the value of an attribute or remove the attribute completely from a node

let _setAttr = (node, name, value) => value === null ? node.removeAttribute(name) : node.setAttribute(name, value); // Transform  string value to the proper type of value eg. "12" = 12, "[12, 'xyz']" = [12, 'xyz']


let _valfix = value => {
  let validTypes = /^true|false|null|undefined|\d+$/;

  let _fn = v => Function(`"use strict"; return ${v};`)();

  let objectType = /^[[{]([\s\S]+)?[\]}]$/;

  try {
    return validTypes.test(value) ? _fn(value) : objectType.test(value) ? JSON.parse(value.replace(/'/g, "\"")) : value;
  } catch (e) {
    return value;
  }
}; // Decide if the value deserves px at the


let _maybeAddPx = (name, val) => {
  return _is.num(+val) && !_cssNumber.includes(name) ? `${val}px` : val;
}; // Allow default Array methods to work as Element Object methods


let arrProto = Object.getOwnPropertyNames(Array.prototype).reduce(function (acc, i) {
  let _fn = Array.prototype[i];

  if (_is.fn(_fn) && !/map|slice|filter|find/.test(i)) {
    acc[i] = function (...args) {
      let _val = _fn.apply(this, args);

      return _is.undef(_val) ? this : _val;
    };
  }

  return acc;
}, {});

class EleEvt extends _event {}

assign(EleEvt.prototype, arrProto); // Element Object [Based on Zepto.js]

Ele = class extends EleEvt {
  constructor(sel = '', ctxt) {
    super();
    this.sel = sel; // Selector

    this.ele = _elem(this.sel, ctxt); // Element

    for (let i = 0; i < this.ele.length; i++) {
      this[i] = this.ele[i];
    }
  }

  slice(...args) {
    return new Ele([].slice.apply(this, args));
  }

  map(fn) {
    return new Ele(_map(this, (el, i) => fn.call(el, el, i), this));
  }

  on(evt, opts, callback) {
    let _newEvts,
        _evt,
        delegate,
        $super = EleEvt.prototype.on.bind(this);

    if (_is.undef(evt)) {
      return;
    } // If there is no event break


    if (_is.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is.not("arr", evt) && _is.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array


    _evt = _is.obj(evt) && _is.not("arr", evt) ? keys(evt) : evt;
    _newEvts = _evt.filter(val => !(val in this._events), this).join(" ");
    if (_is.str(opts)) delegate = opts;else callback = opts;
    this.forEach(function (el, i) {
      $super(evt, callback);
      applyNative(this, el, _newEvts, i, "addEventListener", delegate);
    }, this);
    return this;
  }

  off(evt, callback) {
    let _evt,
        $super = EleEvt.prototype.off.bind(this);

    if (_is.undef(evt)) {
      return;
    } // If there is no event break


    if (_is.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is.not("arr", evt) && _is.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array


    _evt = (_is.obj(evt) && _is.not("arr", evt) ? keys(evt) : evt).join(" ");
    this.forEach(function (el, i) {
      $super(evt, callback);
      applyNative(this, el, _evt, i, "removeEventListener");
    }, this);
    return this;
  }

  get len() {
    return this.ele.length;
  }

  get length() {
    return this.len;
  }

  each(fn) {
    [].every.call(this, function (el, idx) {
      return fn.call(el, el, idx) !== false;
    });
    return this;
  }

  get(idx) {
    return _is.undef(idx) ? [].slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
  }

  nth(...args) {
    return this.get(...args);
  }

  size() {
    return this.length;
  }

  toArray() {
    return this.get();
  }

  remove() {
    return this.each(el => {
      if (_is.def(el.parentNode)) ;
      el.parentNode.removeChild(el);
    });
  }

  not(sel) {
    let excludes,
        $this = this;
    return new Ele(this.reduce(function (acc, el, idx) {
      if (_is.fn(sel) && _is.def(sel.call)) {
        if (!sel.call(el, el, idx)) acc.push(el);
      } else {
        excludes = _is.str(sel) ? $this.filter(sel) : _is.arrlike(sel) && _is.fn(sel.item) ? [].slice.call(sel) : new Ele(sel);
        if (excludes.indexOf(el) < 0) acc.push(el);
      }

      return acc;
    }, [], this));
  }

  filter(sel) {
    if (_is.fn(sel)) return this.not(this.not(sel));
    return [].filter.call(this, ele => _matches(ele, sel), this);
  }

  has(sel) {
    return this.filter(el => {
      return _is.obj(sel) ? _contains(el, sel) : new Ele(el).find(sel).size();
    });
  }

  eq(idx) {
    return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
  }

  first() {
    let el = this.get(0);
    return el && !_is.obj(el) ? el : new Ele(el);
  }

  last() {
    let el = this.get(-1);
    return el && !_is.obj(el) ? el : new Ele(el);
  }

  find(sel) {
    let result,
        $this = this;
    if (!sel) result = new Ele();else if (_is.obj(sel)) {
      result = new Ele(sel).filter(el => {
        return [].some.call($this, parent => _contains(parent, el));
      });
    } else if (this.length === 1) {
      result = new Ele(_qsa(this.get(0), sel));
    } else {
      result = this.map(el => _qsa(el, sel));
    }
    return result;
  }

  closest(sel, ctxt) {
    let list = _is.obj(sel) && new Ele(sel);
    return new Ele(this.reduce((acc, ele) => {
      do {
        if (list ? list.indexOf(ele) >= 0 : _matches(ele, sel)) break;
        ele = ele !== ctxt && _is.not("doc", ele) && ele.parentNode;
      } while (ele !== null && ele.nodeType === 1);

      if (ele && acc.indexOf(ele) < 0) acc.push(ele);
      return acc;
    }, []));
  }

  parents(sel) {
    let ancestors = [],
        nodes = this;

    while (nodes.length > 0) {
      nodes = nodes.map(el => {
        if ((el = el.parentNode) && !_is.doc(el) && ancestors.indexOf(el) < 0) {
          ancestors.push(el);
          return el;
        }
      });
    }

    return _filter(ancestors, sel);
  } // `pluck` based on underscore.js, but way more powerful


  pluck(prop) {
    return this.map(el => el[prop]);
  }

  parent(sel) {
    return _filter(_uniq(this.pluck('parentNode')), sel);
  }

  children(sel) {
    return _filter(this.map(el => _children(el)), sel);
  }

  contents() {
    return this.map(el => el.contentDocument || [].slice.call(el.childNodes));
  }

  siblings(sel) {
    return _filter(this.map(el => [].filter.call(_children(el.parentNode), child => child !== el)), sel);
  }

  replaceWith(content) {
    return this.before(content).remove();
  }

  clone() {
    return this.map(el => el.cloneNode(true));
  }

  toggle(opt) {
    return this.each(el => {
      let _el = new Ele(el);

      let _opt = opt || _el.style("display") === "none";

      _el[_opt ? "show" : "hide"]();
    });
  }

  prev(sel) {
    return new Ele(this.pluck('previousElementSibling')).filter(sel || '*');
  }

  next(sel) {
    return new Ele(this.pluck('nextElementSibling')).filter(sel || '*');
  }

  html(...args) {
    let [html] = args;
    return args.length ? this.each((el, idx) => {
      let originHTML = el.innerHTML;
      new Ele(el).empty().append(_fnval(html, [idx, originHTML], el));
    }) : this.length ? this.get(0).innerHTML : null;
  }

  text(...args) {
    let [text] = args;
    return args.length ? this.each((el, idx) => {
      let newText = _fnval(text, [idx, el.textContent], el);

      el.textContent = _is.nul(newText) ? '' : `${newText}`;
    }) : this.length ? this.pluck('textContent').join("") : null;
  }

  attr(name, val) {
    let result;

    if (_is.str(name) && _is.undef(val)) {
      result = this.length && this.get(0).nodeType === 1 && this.get(0).getAttribute(name);
      return !_is.nul(result) ? result : undefined;
    } else {
      return this.each((el, idx) => {
        if (el.nodeType !== 1) return;

        if (_is.arr(name)) {
          for (let i in name) _setAttr(el, i, name[i]);
        } else {
          _setAttr(el, name, _fnval(val, [idx, el.getAttribute(name)], el));
        }
      });
    }
  }

  removeAttr(name) {
    return this.each(el => {
      el.nodeType === 1 && name.split(' ').forEach(attr => {
        _setAttr(el, attr);
      });
    });
  }

  data(name, value) {
    let attrName = `data-${name}`.toLowerCase();
    let data = _is.def(value) ? this.attr(attrName, value) : this.attr(attrName);
    return data !== null ? _valfix(data) : undefined;
  }

  val(...args) {
    let [value] = args,
        _el;

    if (args.length) {
      if (_is.nul(value)) value = "";
      return this.each((el, idx) => {
        el.value = _fnval(value, [idx, el.value], el);
      });
    } else {
      _el = this.get(0);
      return _el && (_el.multiple ? new Ele(_el).find('option').filter(el => el.selected).pluck('value') : _el.value);
    }
  }

  offset(coords) {
    let obj;

    if (coords) {
      return this.each((el, idx) => {
        let $this = new Ele(el);

        let _coords = _fnval(coords, [idx, $this.offset()], el);

        let parentOffset = $this.offsetParent().offset();
        let props = {
          top: _coords.top - parentOffset.top,
          left: _coords.left - parentOffset.left
        };
        if ($this.style('position') === 'static') props.position = 'relative';
        $this.style(props);
      });
    }

    if (!this.length) return null;
    if (documentElement !== this.get(0) && !_contains(documentElement, this.get(0))) return {
      top: 0,
      left: 0
    };
    obj = this.get(0).getBoundingClientRect();
    return {
      left: obj.left + window.pageXOffset,
      top: obj.top + window.pageYOffset,
      width: Math.round(obj.width),
      height: Math.round(obj.height)
    };
  }

  style(...args) {
    let [prop, val] = args,
        css = '',
        key;

    if (args.length < 2) {
      let el = this.get(0);
      if (!el) return;

      if (_is.str(prop)) {
        return el.style[prop] || window.getComputedStyle(el, '').getPropertyValue(prop);
      } else if (_is.arr(prop)) {
        let props = {};
        let computedStyle = window.getComputedStyle(el, '');
        prop.forEach(_prop => {
          props[_prop] = el.style[_prop] || computedStyle.getPropertyValue(_prop);
        });
        return props;
      }
    }

    if (_is.str(prop)) {
      if (!val && val !== 0) {
        this.each(el => {
          el.style.removeProperty(prop);
        });
      } else {
        css = prop + ":" + _maybeAddPx(prop, val);
      }
    } else {
      for (key in prop) {
        if (!prop[key] && prop[key] !== 0) {
          this.each(el => {
            el.style.removeProperty(key);
          });
        } else {
          css += key + ':' + _maybeAddPx(key, prop[key]) + ';';
        }
      }
    }

    return this.each(el => {
      el.style.cssText += ';' + css;
    });
  }

  show() {
    return this.style("display", "");
  }

  hide() {
    return this.style("display", "none");
  }

  empty() {
    return this.each(el => {
      el.innerHTML = '';
    });
  }

  index(el) {
    return el ? this.indexOf(new Ele(el).get(0)) : this.parent().children().indexOf(this.get(0));
  }

  hasClass(name) {
    if (!name) return false;
    return [].some.call(this, function (el) {
      return this.test(_getclass(el));
    }, _classRE(name));
  }

  addClass(name) {
    if (!name) return this;
    return this.each(function (el, idx) {
      if (!('className' in el)) return;

      let classList = [],
          cls = _getclass(el);

      _fnval(name, [idx, cls], el).split(/\s+/g).forEach(function (_name) {
        if (!new Ele(this).hasClass(_name)) classList.push(_name);
      }, el);

      classList.length && _getclass(el, cls + (cls ? " " : "") + classList.join(" "));
    });
  }

  removeClass(name) {
    return this.each(function (el, idx) {
      if (!('className' in el)) return;
      if (_is.undef(name)) return _getclass(el, '');

      let classList = _getclass(el);

      _fnval(name, [idx, classList], el).split(/\s+/g).forEach(function (_name) {
        classList = classList.replace(_classRE(_name), " ");
      });

      _getclass(el, classList.trim());
    });
  }

  toggleClass(name, when) {
    if (!name) return this;
    return this.each(function (el, idx) {
      let $this = new Ele(el);

      _fnval(name, [idx, _getclass(el)], el).split(/\s+/g).forEach(function (_name) {
        (_is.undef(when) ? !$this.hasClass(_name) : when) ? $this.addClass(_name) : $this.removeClass(_name);
      });
    });
  }

  scrollTop(val) {
    if (!this.length) return;
    let hasScroll = 'scrollTop' in this.get(0);
    if (_is.undef(val)) return this.get(0)[hasScroll ? "scrollTop" : "pageYOffset"];
    return this.each(function () {
      hasScroll ? this.scrollTop = val : this.scrollTo(this.scrollX, val);
    });
  }

  scrollLeft(val) {
    if (!this.length) return;
    let hasScroll = 'scrollLeft' in this.get(0);
    if (_is.undef(val)) return this.get(0)[hasScroll ? "scrollLeft" : "pageXOffset"];
    return this.each(function () {
      hasScroll ? this.scrollLeft = val : this.scrollTo(val, this.scrollY);
    });
  }

  offsetParent() {
    return this.map(function (el) {
      let parent = el.offsetParent || document.body;

      while (parent && !/^(?:body|html)$/i.test(parent.nodeName) && new Ele(parent).style("position") === "static") parent = parent.offsetParent;

      return parent;
    });
  }

  position() {
    if (!this.length) return;
    let elem = this.get(0),
        offsetParent = this.offsetParent(),
        offset = this.offset(),
        parentOffset = /^(?:body|html)$/i.test(offsetParent[0].nodeName) ? {
      top: 0,
      left: 0
    } : offsetParent.offset();
    offset.top -= parseFloat(new Ele(elem).style('margin-top')) || 0;
    offset.left -= parseFloat(new Ele(elem).style('margin-left')) || 0;
    parentOffset.top += parseFloat(new Ele(offsetParent[0]).style('border-top-width')) || 0;
    parentOffset.left += parseFloat(new Ele(offsetParent[0]).style('border-left-width')) || 0;
    return {
      top: offset.top - parentOffset.top,
      left: offset.left - parentOffset.left
    };
  }

};
assign(Ele.prototype, // Generate shortforms for events eg. .click(), .hover(), etc...
nativeEvents.reduce((acc, name) => {
  // Handle event binding
  acc[name] = function (...args) {
    return this.on(name, ...args);
  };

  return acc;
}, {
  hover(fnOver, fnOut) {
    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
  }

}), // Generate the `width` and `height` methods
['width', 'height'].reduce((acc, sz) => {
  let prop = _capital(sz);

  acc[sz] = function (value) {
    let offset,
        el = this.get(0);

    if (_is.undef(value)) {
      if (_is.win(el)) {
        return el[`inner${prop}`];
      } else if (_is.doc(el)) {
        return el.documentElement[`scroll${prop}`];
      } else {
        return (offset = this.offset()) && offset[sz];
      }
    } else {
      return this.each((_el, idx) => {
        el = new Ele(_el);
        el.style(sz, _fnval(value, [idx, el[sz]()], _el));
      });
    }
  };

  return acc;
}, {}), // Generate the `after`, `prepend`, `before`, `append`, `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
['after', 'prepend', 'before', 'append'].reduce(function (acc, fn, idx) {
  let inside = idx % 2; //=> prepend, append

  acc[fn] = function (...args) {
    // Arguments can be nodes, arrays of nodes, Element objects and HTML strings
    let clone = this.length > 1;

    let nodes = _map(args, function (arg) {
      if (_is.arr(arg)) {
        return arg.reduce((acc, el) => {
          if (_is.def(el.nodeType)) acc.push(el);else if (_is.inst(el, Ele)) acc = acc.concat(el.get());else if (_is.str(el)) acc = acc.concat(_createElem(el));
          return acc;
        }, []);
      }

      return _is.obj(arg) || _is.nul(arg) ? arg : _createElem(arg);
    });

    return this.each(function (target) {
      let parent = inside ? target : target.parentNode;

      let parentInDoc = _contains(documentElement, parent);

      let next = target.nextSibling,
          first = target.firstChild; // Convert all methods to a "before" operation

      target = [next, first, target, null][idx];
      nodes.forEach(function (node) {
        if (clone) node = node.cloneNode(true);else if (!parent) return new Ele(node).remove();
        parent.insertBefore(node, target);

        if (parentInDoc) {
          traverseDF(node, function (el) {
            if (!_is.nul(el.nodeName) && el.nodeName.toUpperCase() === 'SCRIPT' && (!el.type || el.type === 'text/javascript') && !el.src) {
              let target = el.ownerDocument ? el.ownerDocument.defaultView : window;
              target.eval.call(target, el.innerHTML);
            }
          });
        }
      });
    });
  }; // after    => insertAfter, prepend  => prependTo
  // before   => insertBefore, append   => appendTo


  acc[inside ? `${fn}To` : `insert${_capital(fn)}`] = function (html) {
    new Ele(html)[fn](this);
    return this;
  };

  return acc;
}, {}));
let el = (sel, ctxt) => {
  return new Ele(sel, ctxt);
};
assign(Element.prototype, {
  toEl() {
    return el(this);
  }

});

var lib$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Plugin = function () {
    function Plugin() {
      _classCallCheck(this, Plugin);

      this.isSwupPlugin = true;
    }

    _createClass(Plugin, [{
      key: "mount",
      value: function mount() {// this is mount method rewritten by class extending
        // and is executed when swup is enabled with plugin
      }
    }, {
      key: "unmount",
      value: function unmount() {// this is unmount method rewritten by class extending
        // and is executed when swup with plugin is disabled
      }
    }, {
      key: "_beforeMount",
      value: function _beforeMount() {// here for any future hidden auto init
      }
    }, {
      key: "_afterUnmount",
      value: function _afterUnmount() {} // here for any future hidden auto-cleanup
      // this is here so we can tell if plugin was created by extending this class

    }]);

    return Plugin;
  }();

  exports.default = Plugin;
});
unwrapExports(lib$1);

var lib$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Scrl = function Scrl(options) {
    var _this = this;

    _classCallCheck(this, Scrl);

    this._raf = null;
    this._positionY = 0;
    this._velocityY = 0;
    this._targetPositionY = 0;
    this._targetPositionYWithOffset = 0;
    this._direction = 0;

    this.scrollTo = function (offset) {
      if (offset && offset.nodeType) {
        // the offset is element
        _this._targetPositionY = Math.round(offset.getBoundingClientRect().top + window.pageYOffset);
      } else if (parseInt(_this._targetPositionY) === _this._targetPositionY) {
        // the offset is a number
        _this._targetPositionY = Math.round(offset);
      } else {
        console.error('Argument must be a number or an element.');
        return;
      } // don't animate beyond the document height


      if (_this._targetPositionY > document.documentElement.scrollHeight - window.innerHeight) {
        _this._targetPositionY = document.documentElement.scrollHeight - window.innerHeight;
      } // calculated required values


      _this._positionY = document.body.scrollTop || document.documentElement.scrollTop;
      _this._direction = _this._positionY > _this._targetPositionY ? -1 : 1;
      _this._targetPositionYWithOffset = _this._targetPositionY + _this._direction;
      _this._velocityY = 0;

      if (_this._positionY !== _this._targetPositionY) {
        // start animation
        _this.options.onStart();

        _this._animate();
      } else {
        // page is already at the position
        _this.options.onAlreadyAtPositions();
      }
    };

    this._animate = function () {
      var distance = _this._update();

      _this._render();

      if (_this._direction === 1 && _this._targetPositionY > _this._positionY || _this._direction === -1 && _this._targetPositionY < _this._positionY) {
        // calculate next position
        _this._raf = requestAnimationFrame(_this._animate);

        _this.options.onTick();
      } else {
        // finish and set position to the final position
        _this._positionY = _this._targetPositionY;

        _this._render();

        _this._raf = null;

        _this.options.onTick();

        _this.options.onEnd(); // this.triggerEvent('scrollDone')

      }
    };

    this._update = function () {
      var distance = _this._targetPositionYWithOffset - _this._positionY;
      var attraction = distance * _this.options.acceleration;
      _this._velocityY += attraction;
      _this._velocityY *= _this.options.friction;
      _this._positionY += _this._velocityY;
      return Math.abs(distance);
    };

    this._render = function () {
      window.scrollTo(0, _this._positionY);
    }; // default options


    var defaults = {
      onAlreadyAtPositions: function onAlreadyAtPositions() {},
      onCancel: function onCancel() {},
      onEnd: function onEnd() {},
      onStart: function onStart() {},
      onTick: function onTick() {},
      friction: .7,
      // 1 - .3
      acceleration: .04 // merge options

    };
    this.options = _extends({}, defaults, options); // set reverse friction

    if (options && options.friction) {
      this.options.friction = 1 - options.friction;
    } // register listener for cancel on wheel event


    window.addEventListener('mousewheel', function (event) {
      if (_this._raf) {
        _this.options.onCancel();

        cancelAnimationFrame(_this._raf);
        _this._raf = null;
      }
    }, {
      passive: true
    });
  };

  exports.default = Scrl;
});
unwrapExports(lib$2);

var lib$3 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var _plugin2 = _interopRequireDefault(lib$1);

  var _scrl2 = _interopRequireDefault(lib$2);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ScrollPlugin = function (_Plugin) {
    _inherits(ScrollPlugin, _Plugin);

    function ScrollPlugin(options) {
      _classCallCheck(this, ScrollPlugin);

      var _this = _possibleConstructorReturn(this, (ScrollPlugin.__proto__ || Object.getPrototypeOf(ScrollPlugin)).call(this));

      _this.name = "ScrollPlugin";

      _this.onSamePage = function () {
        _this.swup.scrollTo(0);
      };

      _this.onSamePageWithHash = function (event) {
        var link = event.delegateTarget;
        var element = document.querySelector(link.hash);
        var top = element.getBoundingClientRect().top + window.pageYOffset;

        _this.swup.scrollTo(top);
      };

      _this.onTransitionStart = function (popstate) {
        if (_this.options.doScrollingRightAway && !_this.swup.scrollToElement) {
          _this.doScrolling(popstate);
        }
      };

      _this.onContentReplaced = function (popstate) {
        if (!_this.options.doScrollingRightAway || _this.swup.scrollToElement) {
          _this.doScrolling(popstate);
        }
      };

      _this.doScrolling = function (popstate) {
        var swup = _this.swup;

        if (!popstate || swup.options.animateHistoryBrowsing) {
          if (swup.scrollToElement != null) {
            var element = document.querySelector(swup.scrollToElement);

            if (element != null) {
              var top = element.getBoundingClientRect().top + window.pageYOffset;
              swup.scrollTo(top);
            } else {
              console.warn('Element ' + swup.scrollToElement + ' not found');
            }

            swup.scrollToElement = null;
          } else {
            swup.scrollTo(0);
          }
        }
      };

      var defaultOptions = {
        doScrollingRightAway: false,
        animateScroll: true,
        scrollFriction: 0.3,
        scrollAcceleration: 0.04
      };
      _this.options = _extends({}, defaultOptions, options);
      return _this;
    }

    _createClass(ScrollPlugin, [{
      key: 'mount',
      value: function mount() {
        var _this2 = this;

        var swup = this.swup; // add empty handlers array for submitForm event

        swup._handlers.scrollDone = [];
        swup._handlers.scrollStart = [];
        this.scrl = new _scrl2.default({
          onStart: function onStart() {
            return swup.triggerEvent('scrollStart');
          },
          onEnd: function onEnd() {
            return swup.triggerEvent('scrollDone');
          },
          onCancel: function onCancel() {
            return swup.triggerEvent('scrollDone');
          },
          friction: this.options.scrollFriction,
          acceleration: this.options.scrollAcceleration
        }); // set scrollTo method of swup and animate based on current animateScroll option

        swup.scrollTo = function (offset) {
          if (_this2.options.animateScroll) {
            _this2.scrl.scrollTo(offset);
          } else {
            swup.triggerEvent('scrollStart');
            window.scrollTo(0, offset);
            swup.triggerEvent('scrollDone');
          }
        }; // disable browser scroll control on popstates when
        // animateHistoryBrowsing option is enabled in swup


        if (swup.options.animateHistoryBrowsing) {
          window.history.scrollRestoration = 'manual';
        } // scroll to the top of the page


        swup.on('samePage', this.onSamePage); // scroll to referenced element on the same page

        swup.on('samePageWithHash', this.onSamePageWithHash); // scroll to the referenced element

        swup.on('transitionStart', this.onTransitionStart); // scroll to the referenced element when it's in the page (after render)

        swup.on('contentReplaced', this.onContentReplaced);
      }
    }, {
      key: 'unmount',
      value: function unmount() {
        this.swup.scrollTo = null;
        delete this.scrl;
        this.scrl = null;
        this.swup.off('samePage', this.onSamePage);
        this.swup.off('samePageWithHash', this.onSamePageWithHash);
        this.swup.off('transitionStart', this.onTransitionStart);
        this.swup.off('contentReplaced', this.onContentReplaced);
        this.swup._handlers.scrollDone = null;
        this.swup._handlers.scrollStart = null;
        window.history.scrollRestoration = 'auto';
      }
    }]);

    return ScrollPlugin;
  }(_plugin2.default);

  exports.default = ScrollPlugin;
});
var scrollPlugin = unwrapExports(lib$3);

let _global = el(window);
let _document = el(document);
let _body = el("html, body");

/*
 * anime.js v3.1.0
 * (c) 2019 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */
// Defaults
var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};
var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};
var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective']; // Caching

var cache = {
  CSS: {},
  springs: {}
}; // Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) {
    return Array.isArray(a);
  },
  obj: function (a) {
    return stringContains(Object.prototype.toString.call(a), 'Object');
  },
  pth: function (a) {
    return is.obj(a) && a.hasOwnProperty('totalLength');
  },
  svg: function (a) {
    return a instanceof SVGElement;
  },
  inp: function (a) {
    return a instanceof HTMLInputElement;
  },
  dom: function (a) {
    return a.nodeType || is.svg(a);
  },
  str: function (a) {
    return typeof a === 'string';
  },
  fnc: function (a) {
    return typeof a === 'function';
  },
  und: function (a) {
    return typeof a === 'undefined';
  },
  hex: function (a) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);
  },
  rgb: function (a) {
    return /^rgb/.test(a);
  },
  hsl: function (a) {
    return /^hsl/.test(a);
  },
  col: function (a) {
    return is.hex(a) || is.rgb(a) || is.hsl(a);
  },
  key: function (a) {
    return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes';
  }
}; // Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) {
    return parseFloat(p);
  }) : [];
} // Spring solver inspired by Webkit Copyright  2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js


function spring(string, duration) {
  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity = minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? duration * t / 1000 : t;

    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }

    if (t === 0 || t === 1) {
      return t;
    }

    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];

    if (cached) {
      return cached;
    }

    var frame = 1 / 6;
    var elapsed = 0;
    var rest = 0;

    while (true) {
      elapsed += frame;

      if (solver(elapsed) === 1) {
        rest++;

        if (rest >= 16) {
          break;
        }
      } else {
        rest = 0;
      }
    }

    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;
} // Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function


function steps(steps) {
  if (steps === void 0) steps = 10;
  return function (t) {
    return Math.round(t * steps) * (1 / steps);
  };
} // BezierEasing https://github.com/gre/bezier-easing


var bezier = function () {
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);

    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
      return;
    }

    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {
      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) {
        return x;
      }

      if (x === 0 || x === 1) {
        return x;
      }

      return calcBezier(getTForX(x), mY1, mY2);
    };
  }

  return bezier;
}();

var penner = function () {
  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)
  var eases = {
    linear: function () {
      return function (t) {
        return t;
      };
    }
  };
  var functionEasings = {
    Sine: function () {
      return function (t) {
        return 1 - Math.cos(t * Math.PI / 2);
      };
    },
    Circ: function () {
      return function (t) {
        return 1 - Math.sqrt(1 - t * t);
      };
    },
    Back: function () {
      return function (t) {
        return t * t * (3 * t - 2);
      };
    },
    Bounce: function () {
      return function (t) {
        var pow2,
            b = 4;

        while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {}

        return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
      };
    },
    Elastic: function (amplitude, period) {
      if (amplitude === void 0) amplitude = 1;
      if (period === void 0) period = .5;
      var a = minMax(amplitude, 1, 10);
      var p = minMax(period, .1, 2);
      return function (t) {
        return t === 0 || t === 1 ? t : -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);
      };
    }
  };
  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];
  baseEasings.forEach(function (name, i) {
    functionEasings[name] = function () {
      return function (t) {
        return Math.pow(t, i + 2);
      };
    };
  });
  Object.keys(functionEasings).forEach(function (name) {
    var easeIn = functionEasings[name];
    eases['easeIn' + name] = easeIn;

    eases['easeOut' + name] = function (a, b) {
      return function (t) {
        return 1 - easeIn(a, b)(1 - t);
      };
    };

    eases['easeInOut' + name] = function (a, b) {
      return function (t) {
        return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;
      };
    };
  });
  return eases;
}();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) {
    return easing;
  }

  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);

  switch (name) {
    case 'spring':
      return spring(easing, duration);

    case 'cubicBezier':
      return applyArguments(bezier, args);

    case 'steps':
      return applyArguments(steps, args);

    default:
      return applyArguments(ease, args);
  }
} // Strings


function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch (e) {
    return;
  }
} // Arrays


function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];

  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];

      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }

  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) {
    return a.concat(is.arr(b) ? flattenArray(b) : b);
  }, []);
}

function toArray(o) {
  if (is.arr(o)) {
    return o;
  }

  if (is.str(o)) {
    o = selectString(o) || o;
  }

  if (o instanceof NodeList || o instanceof HTMLCollection) {
    return [].slice.call(o);
  }

  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) {
    return a === val;
  });
} // Objects


function cloneObject(o) {
  var clone = {};

  for (var p in o) {
    clone[p] = o[p];
  }

  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);

  for (var p in o1) {
    o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];
  }

  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);

  for (var p in o2) {
    o[p] = is.und(o1[p]) ? o2[p] : o1[p];
  }

  return o;
} // Colors


function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? "rgba(" + rgb[1] + ",1)" : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return "rgba(" + r + "," + g + "," + b + ",1)";
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;

  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }

    if (t > 1) {
      t -= 1;
    }

    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }

    if (t < 1 / 2) {
      return q;
    }

    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
  }

  var r, g, b;

  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return "rgba(" + r * 255 + "," + g * 255 + "," + b * 255 + "," + a + ")";
}

function colorToRgb(val) {
  if (is.rgb(val)) {
    return rgbToRgba(val);
  }

  if (is.hex(val)) {
    return hexToRgba(val);
  }

  if (is.hsl(val)) {
    return hslToRgba(val);
  }
} // Units


function getUnit(val) {
  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);

  if (split) {
    return split[1];
  }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') {
    return 'px';
  }

  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) {
    return 'deg';
  }
} // Values


function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) {
    return val;
  }

  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);

  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) {
    return value;
  }

  var cached = cache.CSS[value + unit];

  if (!is.und(cached)) {
    return cached;
  }

  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || is.svg(el) && el[prop])) {
    return 'attribute';
  }

  if (is.dom(el) && arrayContains(validTransforms, prop)) {
    return 'transform';
  }

  if (is.dom(el) && prop !== 'transform' && getCSSValue(el, prop)) {
    return 'css';
  }

  if (el[prop] != null) {
    return 'object';
  }
}

function getElementTransforms(el) {
  if (!is.dom(el)) {
    return;
  }

  var str = el.style.transform || '';
  var reg = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m;

  while (m = reg.exec(str)) {
    transforms.set(m[1], m[2]);
  }

  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;

  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }

  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform':
      return getTransformValue(target, propName, animatable, unit);

    case 'css':
      return getCSSValue(target, propName, unit);

    case 'attribute':
      return getAttribute(target, propName);

    default:
      return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);

  if (!operator) {
    return to;
  }

  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));

  switch (operator[0][0]) {
    case '+':
      return x + y + u;

    case '-':
      return x - y + u;

    case '*':
      return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) {
    return colorToRgb(val);
  }

  if (/\s/g.test(val)) {
    return val;
  }

  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;

  if (unit) {
    return unitLess + unit;
  }

  return unitLess;
} // getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744


function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return getAttribute(el, 'width') * 2 + getAttribute(el, 'height') * 2;
}

function getLineLength(el) {
  return getDistance({
    x: getAttribute(el, 'x1'),
    y: getAttribute(el, 'y1')
  }, {
    x: getAttribute(el, 'x2'),
    y: getAttribute(el, 'y2')
  });
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;

  for (var i = 0; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);

    if (i > 0) {
      totalLength += getDistance(previousPos, currentPos);
    }

    previousPos = currentPos;
  }

  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
} // Path animation


function getTotalLength(el) {
  if (el.getTotalLength) {
    return el.getTotalLength();
  }

  switch (el.tagName.toLowerCase()) {
    case 'circle':
      return getCircleLength(el);

    case 'rect':
      return getRectLength(el);

    case 'line':
      return getLineLength(el);

    case 'polyline':
      return getPolylineLength(el);

    case 'polygon':
      return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
} // Motion path


function getParentSvgEl(el) {
  var parentEl = el.parentNode;

  while (is.svg(parentEl)) {
    if (!is.svg(parentEl.parentNode)) {
      break;
    }

    parentEl = parentEl.parentNode;
  }

  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width / viewBox[2],
    h: height / viewBox[3]
  };
}

function getPath(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function (property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    };
  };
}

function getPathProgress(path, progress) {
  function point(offset) {
    if (offset === void 0) offset = 0;
    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }

  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);

  switch (path.property) {
    case 'x':
      return (p.x - svg.x) * svg.w;

    case 'y':
      return (p.y - svg.y) * svg.h;

    case 'angle':
      return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
} // Decompose value


function decomposeValue(val, unit) {
  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation

  var value = validateValue(is.pth(val) ? val.totalLength : val, unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: is.str(val) || unit ? value.split(rgx) : []
  };
} // Animatables


function parseTargets(targets) {
  var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets)) : [];
  return filterArray(targetsArray, function (item, pos, self) {
    return self.indexOf(item) === pos;
  });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {
      target: t,
      id: i,
      total: parsed.length,
      transforms: {
        list: getElementTransforms(t)
      }
    };
  });
} // Properties


function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings); // Override duration if easing is a spring

  if (/^spring/.test(settings.easing)) {
    settings.duration = spring(settings.easing);
  }

  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = l === 2 && !is.obj(prop[0]);

    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) {
        settings.duration = tweenSettings.duration / l;
      }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {
        value: prop
      };
    }
  }

  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = is.obj(v) && !is.pth(v) ? v : {
      value: v
    }; // Default delay value should only be applied to the first tween

    if (is.und(obj.delay)) {
      obj.delay = !i ? tweenSettings.delay : 0;
    } // Default endDelay value should only be applied to the last tween


    if (is.und(obj.endDelay)) {
      obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;
    }

    return obj;
  }).map(function (k) {
    return mergeObjects(k, settings);
  });
}

function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) {
    return Object.keys(key);
  })), function (p) {
    return is.key(p);
  }).reduce(function (a, b) {
    if (a.indexOf(b) < 0) {
      a.push(b);
    }

    return a;
  }, []);
  var properties = {};

  var loop = function (i) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};

      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) {
            newKey.value = key[p];
          }
        } else {
          newKey[p] = key[p];
        }
      }

      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) loop(i);

  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;

  if (keyframes) {
    params = mergeObjects(flattenKeyframes(keyframes), params);
  }

  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }

  return properties;
} // Tweens


function normalizeTweenValues(tween, animatable) {
  var t = {};

  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);

    if (is.arr(value)) {
      value = value.map(function (v) {
        return getFunctionValue(v, animatable);
      });

      if (value.length === 1) {
        value = value[0];
      }
    }

    t[p] = value;
  }

  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;

    if (is.und(to)) {
      to = previousValue;
    }

    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isColor = is.col(tween.from.original);

    if (tween.isColor) {
      tween.round = 1;
    }

    previousTween = tween;
    return tween;
  });
} // Tween progress


var setProgressValue = {
  css: function (t, p, v) {
    return t.style[p] = v;
  },
  attribute: function (t, p, v) {
    return t.setAttribute(p, v);
  },
  object: function (t, p, v) {
    return t[p] = v;
  },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);

    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) {
        str += prop + "(" + value + ") ";
      });
      t.style.transform = str;
    }
  }
}; // Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
} // Animations


function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);

  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    };
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) {
    return !is.und(a);
  });
} // Create Instance


function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;

  var getTlOffset = function (anim) {
    return anim.timelineOffset ? anim.timelineOffset : 0;
  };

  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.duration;
  })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.delay;
  })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.duration - anim.endDelay;
  })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
} // Core


var activeInstances = [];
var pausedInstances = [];
var raf;

var engine = function () {
  function play() {
    raf = requestAnimationFrame(step);
  }

  function step(t) {
    var activeInstancesLength = activeInstances.length;

    if (activeInstancesLength) {
      var i = 0;

      while (i < activeInstancesLength) {
        var activeInstance = activeInstances[i];

        if (!activeInstance.paused) {
          activeInstance.tick(t);
        } else {
          var instanceIndex = activeInstances.indexOf(activeInstance);

          if (instanceIndex > -1) {
            activeInstances.splice(instanceIndex, 1);
            activeInstancesLength = activeInstances.length;
          }
        }

        i++;
      }

      play();
    } else {
      raf = cancelAnimationFrame(raf);
    }
  }

  return play;
}();

function handleVisibilityChange() {
  if (document.hidden) {
    activeInstances.forEach(function (ins) {
      return ins.pause();
    });
    pausedInstances = activeInstances.slice(0);
    anime.running = activeInstances = [];
  } else {
    pausedInstances.forEach(function (ins) {
      return ins.play();
    });
  }
}

if (typeof document !== 'undefined') {
  document.addEventListener('visibilitychange', handleVisibilityChange);
} // Public Instance


function anime(params) {
  if (params === void 0) params = {};
  var startTime = 0,
      lastTime = 0,
      now = 0;
  var children,
      childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) {
      return resolve = _resolve;
    });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  var promise = makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;

    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }

    instance.reversed = !instance.reversed;
    children.forEach(function (child) {
      return child.reversed = instance.reversed;
    });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
  }

  function seekChild(time, child) {
    if (child) {
      child.seek(time - child.timelineOffset);
    }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) {
        seekChild(time, children[i]);
      }
    } else {
      for (var i$1 = childrenLength; i$1--;) {
        seekChild(time, children[i$1]);
      }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;

    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength]; // Only check for keyframes if there is more than one tween

      if (tweenLength) {
        tween = filterArray(tweens, function (t) {
          return insTime < t.end;
        })[0] || tween;
      }

      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = void 0;

      for (var n = 0; n < toNumbersLength; n++) {
        var value = void 0;
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;

        if (!tween.isPath) {
          value = fromNumber + eased * (toNumber - fromNumber);
        } else {
          value = getPathProgress(tween.value, eased * toNumber);
        }

        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }

        numbers.push(value);
      } // Manual Array.reduce for better performances


      var stringsLength = strings.length;

      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];

        for (var s = 0; s < stringsLength; s++) {
          var a = strings[s];
          var b = strings[s + 1];
          var n$1 = numbers[s];

          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }

      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) {
      instance[cb](instance);
    }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax(insTime / insDuration * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;

    if (children) {
      syncInstanceChildren(insTime);
    }

    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
    }

    if (!instance.loopBegan && instance.currentTime > 0) {
      instance.loopBegan = true;
      setCallback('loopBegin');
    }

    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }

    if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {
      setAnimationsProgress(insDuration);
    }

    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }

      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }

    instance.currentTime = minMax(insTime, 0, insDuration);

    if (instance.began) {
      setCallback('update');
    }

    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();

      if (!instance.remaining) {
        instance.paused = true;

        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');

          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            promise = makePromise(instance);
          }
        }
      } else {
        startTime = now;
        setCallback('loopComplete');
        instance.loopBegan = false;

        if (instance.direction === 'alternate') {
          toggleInstanceDirection();
        }
      }
    }
  }

  instance.reset = function () {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.loopBegan = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;

    for (var i = childrenLength; i--;) {
      instance.children[i].reset();
    }

    if (instance.reversed && instance.loop !== true || direction === 'alternate' && instance.loop === 1) {
      instance.remaining++;
    }

    setAnimationsProgress(instance.reversed ? instance.duration : 0);
  }; // Set Value helper


  instance.set = function (targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function (t) {
    now = t;

    if (!startTime) {
      startTime = now;
    }

    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
  };

  instance.seek = function (time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function () {
    instance.paused = true;
    resetTime();
  };

  instance.play = function () {
    if (!instance.paused) {
      return;
    }

    if (instance.completed) {
      instance.reset();
    }

    instance.paused = false;
    activeInstances.push(instance);
    resetTime();

    if (!raf) {
      engine();
    }
  };

  instance.reverse = function () {
    toggleInstanceDirection();
    resetTime();
  };

  instance.restart = function () {
    instance.reset();
    instance.play();
  };

  instance.reset();

  if (instance.autoplay) {
    instance.play();
  }

  return instance;
} // Remove targets from animation


function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargets(targets) {
  var targetsArray = parseTargets(targets);

  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    var animations = instance.animations;
    var children = instance.children;
    removeTargetsFromAnimations(targetsArray, animations);

    for (var c = children.length; c--;) {
      var child = children[c];
      var childAnimations = child.animations;
      removeTargetsFromAnimations(targetsArray, childAnimations);

      if (!childAnimations.length && !child.children.length) {
        children.splice(c, 1);
      }
    }

    if (!animations.length && !children.length) {
      instance.pause();
    }
  }
} // Stagger helpers


function stagger(val, params) {
  if (params === void 0) params = {};
  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) {
      fromIndex = 0;
    }

    if (fromCenter) {
      fromIndex = (t - 1) / 2;
    }

    if (fromLast) {
      fromIndex = t - 1;
    }

    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
          var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
          var toX = index % grid[0];
          var toY = Math.floor(index / grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

          if (axis === 'x') {
            value = -distanceX;
          }

          if (axis === 'y') {
            value = -distanceY;
          }

          values.push(value);
        }

        maxValue = Math.max.apply(Math, values);
      }

      if (easing) {
        values = values.map(function (val) {
          return easing(val / maxValue) * maxValue;
        });
      }

      if (direction === 'reverse') {
        values = values.map(function (val) {
          return axis ? val < 0 ? val * -1 : -val : Math.abs(maxValue - val);
        });
      }
    }

    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + spacing * (Math.round(values[i] * 100) / 100) + unit;
  };
} // Timeline


function timeline(params) {
  if (params === void 0) params = {};
  var tl = anime(params);
  tl.duration = 0;

  tl.add = function (instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;

    if (tlIndex > -1) {
      activeInstances.splice(tlIndex, 1);
    }

    function passThrough(ins) {
      ins.passThrough = true;
    }

    for (var i = 0; i < children.length; i++) {
      passThrough(children[i]);
    }

    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();

    if (tl.autoplay) {
      tl.play();
    }

    return tl;
  };

  return tl;
}

anime.version = '3.1.0';
anime.speed = 1;
anime.running = activeInstances;
anime.remove = removeTargets;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;

anime.random = function (min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

try {
  let _backToTop = el('#back-to-top');

  let _navbar = el('.navbar');

  let _height = _navbar.height();

  let _focusPt = _height + 20;

  let _load,
      _scroll,
      _scrollEle = _body.get(0); // _scrollEle = window.document.scrollingElement || window.document.body || window.document.documentElement;
  // _scrollEle = el(_scrollEle);


  _navbar.click('.navbar-menu', e => {
    e.preventDefault();

    _navbar.toggleClass("navbar-show");
  });

  _backToTop.click(e => {
    e.preventDefault();
    anime({
      targets: _scrollEle,
      scrollTop: 0,
      duration: 500,
      easing: 'easeInOutQuad'
    });
  });

  let actioncenter = el(".layer-action-center");

  _global.scroll(_scroll = () => {
    _navbar.toggleClass("navbar-focus", _global.scrollTop() + _height >= _focusPt);

    _navbar.hasClass("navbar-show") && _navbar.removeClass("navbar-show");

    if (_global.scrollTop() + _height >= _focusPt * 2) {
      actioncenter.show();
    } else {
      actioncenter.hide();
    }
  });

  _load = () => {
    let _next_layer_btn = el(".next-layer"),
        _next_layer;

    let _img = el(".load-img");

    let _main = el(".main");

    _scroll();

    var body = document.body,
        html = document.documentElement;
    var height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);

    if (height <= window.innerHeight) {
      actioncenter.show();
    }

    _img.each($img => {
      let img = el($img);

      let _core_img = img.find(".core-img").get(0);

      let _placeholder_img = img.find(".placeholder-img");

      if (_core_img.complete) {
        _placeholder_img.addClass("core-img-show");
      } else {
        _core_img.addEventListener("load", function () {
          _placeholder_img.addClass("core-img-show");

          setTimeout(function () {
            _placeholder_img.hide();
          }, 3000);
        }, false);
      }
    });

    _next_layer_btn.click((e, _el) => {
      e.preventDefault();
      _next_layer = el(_el).closest(".layer", _main).next(".layer");
      anime({
        targets: _scrollEle,
        scrollTop: el(_next_layer).offset().top - _height,
        duration: 500,
        easing: 'easeInOutQuad'
      });
    }); // let options = {
    //     root: null,
    //     rootMargin: '0px',
    //     threshold: 0,
    //     // threshold: Array.from(Array(101), (_, x) => x / 100)
    // };
    // let observer = new IntersectionObserver(entries => {
    //     entries.forEach((entry, i) => {
    //         // if (entry.isIntersecting) {
    //         if (entry.intersectionRatio > 0) {
    //             // this.onScreen(entry)
    //             anime({
    //                 targets: entry.target,
    //                 translateY: 0,
    //                 opacity: 1,
    //                 duration: 1000,
    //                 easing: 'easeInOutExpo',
    //                 delay: i * 500,
    //                 begin() {
    //                     observer.unobserve(entry.target);
    //                 }
    //             });
    //         } else {
    //             // this.offScreen(entry)
    //         }
    //         // }
    //     });
    // }, options);
    // el(".layer").forEach(_el => {
    //     observer.observe(_el);
    // });

  };

  _load();

  new swup({
    requestHeaders: {
      "X-Requested-With": "swup",
      // So we can tell request comes from swup
      "x-partial": "swup" // Request a partial html page

    },
    plugins: [new scrollPlugin({
      doScrollingRightAway: false,
      animateScroll: true,
      scrollFriction: 0.3,
      scrollAcceleration: 0.04
    })] // new preload(),

  }) // This event runs for every page view after initial load
  .on('contentReplaced', _load);
} catch (e) {
  let _img = document.getElementsByClassName("placeholder-img");

  let _navbar = document.getElementsByClassName("navbar");

  _navbar.forEach(function (nav) {
    nav.classList.add("navbar-focus");
  });

  _img.forEach(function (img) {
    img.classList.add("core-img-show");
  });

  console.error(e);
}
