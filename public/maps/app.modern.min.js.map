{"version":3,"sources":["src/js/components/util.js","src/js/app.js","node_modules/rellax/rellax.js","src/js/components/event.js","src/js/components/ele.js","src/js/components/dom.js"],"names":["assign","Object","keys","isArray","Array","_capital","val","toUpperCase","slice","_is","type","_isInst","ctor","obj","_type","el","Element","Document","arrlike","len","length","num","isNaN","usable","v","class","_method","_class","not","args","doc","def","undef","win","window","bool","fn","str","nul","inst","arr","_fnval","ctxt","prototype","apply","STRIP_COMMENTS","ARGUMENT_NAMES","_argNames","fnStr","toString","replace","result","indexOf","match","stripped","i","push","_matches","ele","sel","matchSel","matches","msMatchesSelector","webkitMatchesSelector","call","commonjsGlobal","globalThis","global","self","createCommonjsModule","module","exports","rellax","root","factory","Rellax","options","create","posY","screenY","posX","screenX","blocks","pause","loop","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","oRequestAnimationFrame","callback","setTimeout","loopId","supportsPassive","opts","defineProperty","get","addEventListener","removeEventListener","e","clearLoop","cancelAnimationFrame","mozCancelAnimationFrame","clearTimeout","transformProp","testEl","document","createElement","style","transform","vendors","vendor","undefined","speed","center","wrapper","relativeToWrapper","round","vertical","horizontal","forEach","key","elements","querySelectorAll","elems","nodeType","querySelector","console","warn","init","cssText","innerHeight","innerWidth","setPosition","block","createBlock","cacheBlocks","animate","update","dataPercentage","getAttribute","dataSpeed","dataZindex","dataMin","dataMax","wrapperPosY","scrollTop","pageYOffset","documentElement","body","offsetTop","scrollLeft","pageXOffset","blockTop","getBoundingClientRect","top","blockHeight","clientHeight","offsetHeight","scrollHeight","blockLeft","left","blockWidth","clientWidth","offsetWidth","scrollWidth","percentageY","percentageX","bases","updatePosition","searchResult","exec","index","trimmedStyle","delimiter","baseX","x","baseY","y","height","width","zindex","min","max","oldY","oldX","parentNode","scrollPosY","valueX","valueY","Math","deferredUpdate","passive","positions","positionY","positionX","translate","destroy","refresh","_event","constructor","this","_events","_emit","_preEvent","evt","_eventApp","scope","event","on","$EvtApp","$evt","split","off","_off","_Evt","app","splice","once","$Fn","emit","$Evt","$args","includes","_evt","listeners","map","listenerValues","clear","_eventCount","clearListeners","_names","add","bind","remove","unbind","fire","trigger","callbacks","noop","capture","tagRE","tagExpandRE","_qsa","dom","classes","test","charAt","getElementById","substr","getElementsByClassName","getElementsByTagName","_createElem","html","container","innerHTML","childNodes","removeChild","_elem","trim","NodeList","filter","item","ready","ele$1","super","_newEvts","delegate","$super","useCapture","target","readyState","attachEvent","_el","idx","toArray","first","_concat","concat","_map","each","every","_contains","parent","node","contains","_cssNumber","_maybeAddPx","name","prop","css","getComputedStyle","getPropertyValue","props","computedStyle","_prop","removeProperty","_size","sz","value","_offset","offset","$el","coords","$this","_coords","parentOffset","offsetParent","position","classcache","_classRE","RegExp","getclass","className","svg","baseVal","hasClass","some","addClass","classList","cls","_name","join","removeClass","toggleClass","when","nodeName","onready","onload","onblur","onfocus","onfocusin","onfocusout","onresize","onclick","onscroll","ondblclick","onmousedown","onmouseup","onmousemove","onmouseover","onmouseout","onmouseenter","onmouseleave","onchange","onselect","onsubmit","onkeydown","onkeypress","onkeyup","oncontextmenu","reduce","acc","onhover","fnOver","fnOut","_navbar","preventDefault","log","_img","nav","img"],"mappings":"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","file":"../js/app.modern.min.js","sourcesContent":["// export const { assign, keys, values } = Object;\n// export let { isArray, from, of } = Array;\nexport const assign = Object.assign;\nexport const values = Object.values;\nexport const keys = Object.keys;\n\nexport const isArray = Array.isArray;\nexport const from = Array.from;\nexport const of = Array.of;\n\n// Remove certain properties\nexport let _removeProps = (prop, obj) => {\n    let newObj = assign({}, obj);\n    prop.forEach(key => delete newObj[key]);\n    return newObj;\n };\n\n// Create an array of values that two array share in common\nexport let _intersect = (a, b) => a.filter(val => b.includes(val));\n\n// Log values\nexport let _log = (...args) => args.forEach(v => console.log(v));\n\n// Capitalize strings\nexport let _capital = val => val[0].toUpperCase() + val.slice(1);\n\n// Test the type of a value\nexport let _is = (val, type) => (typeof val === type);\n\n// Is Instance Of\nlet _isInst = (ctor, obj) => (ctor instanceof obj);\nlet _type = type => { // Tweak of _is\n    return val => _is(val, type);\n};\n\nassign(_is, {\n    el: el => _isInst(el, Element) || _isInst(el, Document),\n    arrlike (obj) {\n        let len = _is(obj.length, \"number\") && obj.length;\n        return len === 0 || len > 0 && (len - 1) in obj;\n    },\n    num: val => !isNaN(val) && _type(\"number\") (val),\n    usable: v => !_is(v, \"undefined\") && v !== null,\n    class: obj => obj && obj._method && obj._class,\n    not: (type, ...args) => !_is[type](...args),\n    doc: ctor => _isInst(ctor, Document),\n    def: v => !_is(v, \"undefined\"),\n    undef: _type(\"undefined\"),\n    win: v => v && v.window,\n    bool: _type(\"boolean\"),\n    fn: _type(\"function\"),\n    str: _type(\"string\"),\n    obj: _type(\"object\"),\n    nul: v => v === null,\n    inst: _isInst,\n    arr: isArray,\n    _type\n});\n\n/**\n * @param  {Function} fn\n * @param  {Array<any>} args\n * @param  {Object} ctxt\n */\nexport let _fnval = (fn, args, ctxt) => {\n    if (!_is.fn(fn) ||\n        keys(fn.prototype || {}).length > 0)\n        { return fn; }\n    return fn.apply(ctxt, args);\n};\n\nlet STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nlet ARGUMENT_NAMES = /(?:^|,)\\s*([^\\s,=]+)/g;\n\n// Argument names\nexport let _argNames = fn => {\n    let fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n    let argsList = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')'));\n    let result = argsList.match( ARGUMENT_NAMES ), stripped = [];\n\n    if (_is.nul(result)) return [];\n    else {\n        for (let i = 0; i < result.length; i ++) {\n            stripped.push( result[i].replace(/[\\s,]/g, '') );\n        }\n\n        return stripped;\n    }\n};\n\n// Get or set a value in an Object, based on it's path\nexport let _path = (obj, path, val) => {\n    path = path.toString().split(/[.,]/g);\n    if (_is.def(val)) {\n        if (path.length > 1) {\n            _path(obj[path.shift()], path, val);\n        } else { obj[path[0]] = val; }\n        return val;\n    } else {\n        path.forEach(_val => { obj = obj[_val]; });\n    }\n    return obj;\n};\n\n/*\n    Builds on path and adds more power,\n    * Allows for multiple paths one value\n    * Using Objects as paths and setting the values individually\n    * Access values as an Array, from multiple paths\n*/\nexport let _attr = (obj, path, val) => {\n    if (_is.obj(path) && !_is.arr(path))\n        { return assign(obj, path); }\n    else if (_is.arr(path)) {\n        if (_is.undef(val)) {\n            return path.map(_key => _path(obj, _key));\n        } else {\n            path.forEach(_key => { _path(obj, _key, val); });\n        }\n    } else { return _path(obj, path, val); }\n    return obj;\n};\n\n// The matches() method checks to see if the Element would be selected by the provided selectorString -- in other words -- checks if the element \"is\" the selector.\nexport let _matches = (ele, sel) => {\n    if (_is.undef(ele)) return;\n    let matchSel = ele.matches || ele.msMatchesSelector || ele.webkitMatchesSelector;\n    if (matchSel) return matchSel.call(ele, sel);\n};\n\n// A more efficient `new` keyword that allows for arrays to be passed as arguments\nexport let _new = function (ctor, args) {\n    let F = function () { return ctor.apply(this, args); };\n    F.prototype = ctor.prototype;\n    return new F();\n};\n\nexport default { _matches, _capital, _is, _intersect, _fnval, _argNames, _path, _attr, _new, assign, keys, values, from, of, _log };\n","// import swup from \"swup\";\n// import { el } from \"./components/ele\";\nimport { _log } from \"./components/util\";\nimport Rellax from \"rellax\";\n// import preload from '@swup/preload-plugin';\n// import scrollPlugin from \"@swup/scroll-plugin\";\n// import { _global, _body } from \"./components/global\";\n// import { _is } from \"./components/util\";\n// import anime from 'animejs';\nimport el, { onclick, toggleClass } from \"./components/dom\";\n// onclick,\ntry {\n    let _navbar = el('.navbar');\n    onclick(_navbar, '.navbar-menu', e => {\n        e.preventDefault();\n        toggleClass(_navbar, \"navbar-show\");\n        console.log(\"Navbar-show\");\n    });\n    new Rellax('.core-img', {\n        speed: -10,\n        // center: true,\n        // wrapper: '.layer-image',\n        round: true,\n        vertical: true,\n        horizontal: false\n    });\n    // let _backToTop = el('#back-to-top');\n\n    // let _height = _navbar.height();\n    // let _focusPt = _height + 20;\n    // let _load, _scroll, _scrollEle = _body.get(0);\n    /*\n    // _scrollEle = window.document.scrollingElement || window.document.body || window.document.documentElement;\n    // _scrollEle = el(_scrollEle);\n    _navbar.click('.navbar-menu', e => {\n        e.preventDefault();\n        _navbar.toggleClass(\"navbar-show\");\n    });\n\n    _backToTop.click(e => {\n        e.preventDefault();\n        anime({\n            targets: _scrollEle,\n            scrollTop: 0,\n            duration: 500,\n            easing: 'easeInOutQuad'\n        });\n    });\n\n    let actioncenter = el(\".layer-action-center\");\n    _global.scroll(_scroll = () => {\n        _navbar.toggleClass(\"navbar-focus\", (_global.scrollTop() + _height) >= _focusPt);\n        _navbar.hasClass(\"navbar-show\") && _navbar.removeClass(\"navbar-show\");\n\n        if ((_global.scrollTop() + _height) >= _focusPt * 2) {\n            actioncenter.show();\n        } else { actioncenter.hide(); }\n    });\n\n\n    _load = () => {\n        let _next_layer_btn = el(\".next-layer\"), _next_layer;\n        let _img = el(\".load-img\");\n        let _main = el(\".main\");\n\n        _scroll();\n\n        var body = document.body,\n            html = document.documentElement;\n\n        var height = Math.max( body.scrollHeight, body.offsetHeight,\n                            html.clientHeight, html.scrollHeight, html.offsetHeight );\n\n        if (height <= window.innerHeight) {\n            actioncenter.show();\n        }\n\n        _img.each($img => {\n            let img = el($img);\n            let _core_img = img.find(\".core-img\").get(0);\n            let _placeholder_img = img.find(\".placeholder-img\");\n\n            if (_is.def(_core_img)) {\n                if (_core_img.complete) {\n                    _placeholder_img.addClass(\"core-img-show\");\n                } else {\n                    _core_img.addEventListener(\"load\", function () {\n                        _placeholder_img.addClass(\"core-img-show\");\n\n                        setTimeout(function () { _placeholder_img.hide(); }, 3000);\n                    }, false);\n                }\n            }\n        });\n\n        _next_layer_btn.click((e, _el) => {\n            e.preventDefault();\n            _next_layer = el(_el).closest(\".layer\", _main).next(\".layer\");\n            anime({\n                targets: _scrollEle,\n                scrollTop: el(_next_layer).offset().top - _height,\n                duration: 500,\n                easing: 'easeInOutQuad'\n            });\n        });\n\n        // let options = {\n        //     root: null,\n        //     rootMargin: '0px',\n        //     threshold: 0,\n        //     // threshold: Array.from(Array(101), (_, x) => x / 100)\n        // };\n\n        // let observer = new IntersectionObserver(entries => {\n        //     entries.forEach((entry, i) => {\n        //         // if (entry.isIntersecting) {\n        //         if (entry.intersectionRatio > 0) {\n        //             // this.onScreen(entry)\n\n        //             anime({\n        //                 targets: entry.target,\n        //                 translateY: 0,\n        //                 opacity: 1,\n        //                 duration: 1000,\n        //                 easing: 'easeInOutExpo',\n        //                 delay: i * 500,\n        //                 begin() {\n        //                     observer.unobserve(entry.target);\n        //                 }\n        //             });\n        //         } else {\n        //             // this.offScreen(entry)\n        //         }\n        //         // }\n        //     });\n        // }, options);\n\n        // el(\".layer\").forEach(_el => {\n        //     observer.observe(_el);\n        // });\n    };\n\n    _load();\n    new swup({\n        requestHeaders: {\n            \"X-Requested-With\": \"swup\", // So we can tell request comes from swup\n            \"x-partial\": \"swup\" // Request a partial html page\n        },\n        plugins: [new scrollPlugin({\n            doScrollingRightAway: false,\n            animateScroll: true,\n            scrollFriction: 0.3,\n            scrollAcceleration: 0.04,\n        })] // new preload(),\n    })\n\n    // This event runs for every page view after initial load\n    .on('contentReplaced', _load); */\n} catch (e) {\n    let _img = [...document.getElementsByClassName(\"placeholder-img\")];\n    let _navbar = [...document.getElementsByClassName(\"navbar\")];\n    _navbar.forEach(function (nav) {\n        nav.classList.add(\"navbar-focus\");\n    });\n    _img.forEach(function (img) {\n        img.classList.add(\"core-img-show\");\n    });\n}","\n// ------------------------------------------\n// Rellax.js\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts\n// ------------------------------------------\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.Rellax = factory();\n  }\n}(typeof window !== \"undefined\" ? window : global, function () {\n  var Rellax = function(el, options){\n    \"use strict\";\n\n    var self = Object.create(Rellax.prototype);\n\n    var posY = 0;\n    var screenY = 0;\n    var posX = 0;\n    var screenX = 0;\n    var blocks = [];\n    var pause = true;\n\n    // check what requestAnimationFrame to use, and if\n    // it's not supported, use the onscroll event\n    var loop = window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      function(callback){ return setTimeout(callback, 1000 / 60); };\n\n    // store the id for later use\n    var loopId = null;\n\n    // Test via a getter in the options object to see if the passive property is accessed\n    var supportsPassive = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function() {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener(\"testPassive\", null, opts);\n      window.removeEventListener(\"testPassive\", null, opts);\n    } catch (e) {}\n\n    // check what cancelAnimation method to use\n    var clearLoop = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout;\n\n    // check which transform property to use\n    var transformProp = window.transformProp || (function(){\n        var testEl = document.createElement('div');\n        if (testEl.style.transform === null) {\n          var vendors = ['Webkit', 'Moz', 'ms'];\n          for (var vendor in vendors) {\n            if (testEl.style[ vendors[vendor] + 'Transform' ] !== undefined) {\n              return vendors[vendor] + 'Transform';\n            }\n          }\n        }\n        return 'transform';\n      })();\n\n    // Default Settings\n    self.options = {\n      speed: -2,\n      center: false,\n      wrapper: null,\n      relativeToWrapper: false,\n      round: true,\n      vertical: true,\n      horizontal: false,\n      callback: function() {},\n    };\n\n    // User defined options (might have more in the future)\n    if (options){\n      Object.keys(options).forEach(function(key){\n        self.options[key] = options[key];\n      });\n    }\n\n    // By default, rellax class\n    if (!el) {\n      el = '.rellax';\n    }\n\n    // check if el is a className or a node\n    var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el];\n\n    // Now query selector\n    if (elements.length > 0) {\n      self.elems = elements;\n    }\n\n    // The elements don't exist\n    else {\n      console.warn(\"Rellax: The elements you're trying to select don't exist.\");\n      return;\n    }\n\n    // Has a wrapper and it exists\n    if (self.options.wrapper) {\n      if (!self.options.wrapper.nodeType) {\n        var wrapper = document.querySelector(self.options.wrapper);\n\n        if (wrapper) {\n          self.options.wrapper = wrapper;\n        } else {\n          console.warn(\"Rellax: The wrapper you're trying to use doesn't exist.\");\n          return;\n        }\n      }\n    }\n\n\n    // Get and cache initial position of all elements\n    var cacheBlocks = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        var block = createBlock(self.elems[i]);\n        blocks.push(block);\n      }\n    };\n\n\n    // Let's kick this script off\n    // Build array for cached element values\n    var init = function() {\n      for (var i = 0; i < blocks.length; i++){\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      blocks = [];\n\n      screenY = window.innerHeight;\n      screenX = window.innerWidth;\n      setPosition();\n\n      cacheBlocks();\n\n      animate();\n\n      // If paused, unpause and set listener for window resizing events\n      if (pause) {\n        window.addEventListener('resize', init);\n        pause = false;\n        // Start the loop\n        update();\n      }\n    };\n\n    // We want to cache the parallax blocks'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n    var createBlock = function(el) {\n      var dataPercentage = el.getAttribute( 'data-rellax-percentage' );\n      var dataSpeed = el.getAttribute( 'data-rellax-speed' );\n      var dataZindex = el.getAttribute( 'data-rellax-zindex' ) || 0;\n      var dataMin = el.getAttribute( 'data-rellax-min' );\n      var dataMax = el.getAttribute( 'data-rellax-max' );\n\n      // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)\n      // ensures elements are positioned based on HTML layout.\n      //\n      // If the element has the percentage attribute, the posY and posX needs to be\n      // the current scroll position's value, so that the elements are still positioned based on HTML layout\n      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n      // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n        wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n      var posY = self.options.vertical ? ( dataPercentage || self.options.center ? wrapperPosY : 0 ) : 0;\n      var posX = self.options.horizontal ? ( dataPercentage || self.options.center ? self.options.wrapper ? self.options.wrapper.scrollLeft : (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft) : 0 ) : 0;\n\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n\n      var blockLeft = posX + el.getBoundingClientRect().left;\n      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;\n\n      // apparently parallax equation everyone uses\n      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);\n      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);\n      if(self.options.center){ percentageX = 0.5; percentageY = 0.5; }\n\n      // Optional individual block speed as data attr, otherwise global speed\n      var speed = dataSpeed ? dataSpeed : self.options.speed;\n\n      var bases = updatePosition(percentageX, percentageY, speed);\n\n      // ~~Store non-translate3d transforms~~\n      // Store inline styles and extract transforms\n      var style = el.style.cssText;\n      var transform = '';\n\n      // Check if there's an inline styled transform\n      var searchResult = /transform\\s*:/i.exec(style);\n      if (searchResult) {\n        // Get the index of the transform\n        var index = searchResult.index;\n\n        // Trim the style to the transform point and get the following semi-colon index\n        var trimmedStyle = style.slice(index);\n        var delimiter = trimmedStyle.indexOf(';');\n\n        // Remove \"transform\" string and save the attribute\n        if (delimiter) {\n          transform = \" \" + trimmedStyle.slice(11, delimiter).replace(/\\s/g,'');\n        } else {\n          transform = \" \" + trimmedStyle.slice(11).replace(/\\s/g,'');\n        }\n      }\n\n      return {\n        baseX: bases.x,\n        baseY: bases.y,\n        top: blockTop,\n        left: blockLeft,\n        height: blockHeight,\n        width: blockWidth,\n        speed: speed,\n        style: style,\n        transform: transform,\n        zindex: dataZindex,\n        min: dataMin,\n        max: dataMax\n      };\n    };\n\n    // set scroll position (posY, posX)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n    var setPosition = function() {\n      var oldY = posY;\n      var oldX = posX;\n\n      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;\n      // If option relativeToWrapper is true, use relative wrapper value instead.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n        posY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n\n\n      if (oldY != posY && self.options.vertical) {\n        // scroll changed, return true\n        return true;\n      }\n\n      if (oldX != posX && self.options.horizontal) {\n        // scroll changed, return true\n        return true;\n      }\n\n      // scroll did not change\n      return false;\n    };\n\n    // Ahh a pure function, gets new transform value\n    // based on scrollPosition and speed\n    // Allow for decimal pixel values\n    var updatePosition = function(percentageX, percentageY, speed) {\n      var result = {};\n      var valueX = (speed * (100 * (1 - percentageX)));\n      var valueY = (speed * (100 * (1 - percentageY)));\n\n      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;\n      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;\n\n      return result;\n    };\n\n    // Remove event listeners and loop again\n    var deferredUpdate = function() {\n      window.removeEventListener('resize', deferredUpdate);\n      window.removeEventListener('orientationchange', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : window).removeEventListener('scroll', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : document).removeEventListener('touchmove', deferredUpdate);\n\n      // loop again\n      loopId = loop(update);\n    };\n\n    // Loop\n    var update = function() {\n      if (setPosition() && pause === false) {\n        animate();\n\n        // loop again\n        loopId = loop(update);\n      } else {\n        loopId = null;\n\n        // Don't animate until we get a position updating event\n        window.addEventListener('resize', deferredUpdate);\n        window.addEventListener('orientationchange', deferredUpdate);\n        (self.options.wrapper ? self.options.wrapper : window).addEventListener('scroll', deferredUpdate, supportsPassive ? { passive: true } : false);\n        (self.options.wrapper ? self.options.wrapper : document).addEventListener('touchmove', deferredUpdate, supportsPassive ? { passive: true } : false);\n      }\n    };\n\n    // Transform3d on parallax element\n    var animate = function() {\n      var positions;\n      for (var i = 0; i < self.elems.length; i++){\n        var percentageY = ((posY - blocks[i].top + screenY) / (blocks[i].height + screenY));\n        var percentageX = ((posX - blocks[i].left + screenX) / (blocks[i].width + screenX));\n\n        // Subtracting initialize value, so element stays in same spot as HTML\n        positions = updatePosition(percentageX, percentageY, blocks[i].speed);// - blocks[i].baseX;\n        var positionY = positions.y - blocks[i].baseY;\n        var positionX = positions.x - blocks[i].baseX;\n\n        // The next two \"if\" blocks go like this:\n        // Check if a limit is defined (first \"min\", then \"max\");\n        // Check if we need to change the Y or the X\n        // (Currently working only if just one of the axes is enabled)\n        // Then, check if the new position is inside the allowed limit\n        // If so, use new position. If not, set position to limit.\n\n        // Check if a min limit is defined\n        if (blocks[i].min !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY <= blocks[i].min ? blocks[i].min : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX <= blocks[i].min ? blocks[i].min : positionX;\n          }\n        }\n\n        // Check if a max limit is defined\n        if (blocks[i].max !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY >= blocks[i].max ? blocks[i].max : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX >= blocks[i].max ? blocks[i].max : positionX;\n          }\n        }\n\n        var zindex = blocks[i].zindex;\n\n        // Move that element\n        // (Set the new translation and append initial inline transforms.)\n        var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;\n        self.elems[i].style[transformProp] = translate;\n      }\n      self.options.callback(positions);\n    };\n\n    self.destroy = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      // Remove resize event listener if not pause, and pause\n      if (!pause) {\n        window.removeEventListener('resize', init);\n        pause = true;\n      }\n\n      // Clear the animation loop to prevent possible memory leak\n      clearLoop(loopId);\n      loopId = null;\n    };\n\n    // Init\n    init();\n\n    // Allow to recalculate the initial values whenever we want\n    self.refresh = init;\n\n    return self;\n  };\n  return Rellax;\n}));\n","import { _is, keys, _argNames } from \"./util\";\n\n// A small event emitter\nexport default class _event {\n    constructor() {\n        this._events = {}; // Event info.\n        this._emit = [];  // Store events set to be emitted\n    }\n\n    // Prepare the event\n    _preEvent(evt) {\n        if (!this._events[evt]) // List of event's\n            { this._events[evt] = []; }\n        return this._events[evt];\n    }\n\n    // Apply event as object\n    _eventApp(callback, scope, event) {\n        return {\n            callback: callback,\n            scope: scope,\n            event: event\n        };\n    }\n\n    // Add a listener for a given event\n    on(evt, callback, scope) {\n        let $EvtApp, $evt;\n        if (_is.undef(evt)) { return; } // If there is no event break\n        if (_is.str(evt)) { evt = evt.split(/\\s/g); }\n        if (!_is.arr(evt) && !_is.obj(evt)) { evt = [evt]; } // Set evt to an array\n\n        // Loop through the list of events\n        keys(evt).forEach(function (key) {\n            $evt = evt[key];\n            if (_is.obj(evt) && !_is.arr(evt)) {\n                $EvtApp = this._eventApp($evt, callback || this, key);\n                this._preEvent(key).push($EvtApp); // Set event list\n            } else {\n                $EvtApp = this._eventApp(callback, scope, $evt);\n                this._preEvent($evt).push($EvtApp); // Set event list\n            }\n        }, this);\n        return this;\n    }\n\n    // Removes a listener for a given event\n    off(evt, callback, scope) {\n        let $evt;\n        if (_is.undef(evt)) { return; } // If there is no event break\n        if (_is.str(evt)) { evt = evt.split(/\\s/g); }\n        if (!_is.arr(evt) && !_is.obj(evt)) { evt = [evt]; } // Set evt to an array\n\n        let _off = function ($evt, callback, scope) {\n            let _Evt = this._preEvent($evt);\n\n            if (callback) {\n                let i = 0, val, app = this._eventApp(callback, scope, $evt);\n                for (; i < _Evt.length; i ++) {\n                    val = _Evt[i];\n                    if (val.callback === app.callback &&\n                         val.scope === app.scope)\n                         { break; }\n                }\n\n                _Evt.splice(i, 1);\n            } else { this._events[$evt] = undefined; }\n        };\n\n        keys(evt).forEach(function (key) {\n            $evt = evt[key];\n            if (_is.obj(evt) && !_is.obj(evt)) {\n                _off.call(this, key, $evt, scope);\n            } else { _off.call(this, $evt, callback, scope); }\n        }, this);\n        return this;\n    }\n\n    // Adds a one time event listener for a given event\n    once(evt, callback, scope) {\n        if (_is.undef(evt)) { return; } // If there is no event break\n        if (_is.str(evt)) { evt = evt.split(/\\s/g); }\n        if (!_is.arr(evt) && !_is.obj(evt)) { evt = [evt]; } // Set evt to an array\n\n        let $Fn = function (...args) {\n            this.off(evt, $Fn, scope);\n            callback.apply(scope, args);\n        };\n\n        this.on(evt, $Fn, scope);\n        return this;\n    }\n\n    // Call all function(s) within an event\n    emit(evt, args, scope) {\n        let $Evt, $args = args;\n        if (_is.undef(evt)) { return; } // If there is no event break\n        if (_is.str(evt)) { evt = evt.split(/\\s/g); }\n        if (!_is.arr(evt)) { evt = [evt]; } // Set evt to an array\n\n        // Loop through the list of events\n        evt.forEach(function ($evt) {\n            $Evt = this._preEvent($evt);\n            if (!this._emit.includes($evt))\n                { this._emit.push($evt); }\n\n            $Evt.forEach(_evt => {\n                $args = args;\n                // Check to see if first param is $evt, if so give details about event\n                if (_argNames(_evt.callback)[0] === \"$evt\")\n                    { $args = [_evt, ...args]; }\n\n                _evt.callback\n                    .apply(_is.undef(_evt.scope) ? scope : _evt.scope, $args);\n            }, this);\n        }, this);\n        return this;\n    }\n\n    // List's all listeners for a given event\n    listeners(evt) {\n        let $Evt = this._preEvent(evt);\n        if (!$Evt.length) { return []; }\n        return $Evt.map(val => val.callback);\n    }\n\n    // List's all listener values for a given event\n    listenerValues(evt, ...args) {\n        let $Evt = this._preEvent(evt);\n        if (!$Evt.length) { return []; }\n        return $Evt.map(val => val.callback.call(val.scope, ...args));\n    }\n\n    // Clear all events\n    clear()\n        { this._eventCount = 0; this._events = {}; return this; }\n\n    // Clear all events\n    clearListeners(evt)\n        { this._events[evt] = []; return this; }\n\n    // Name of all event's\n    get _names() { return Object.keys(this._events); }\n\n    // Number of events\n    get _eventCount() { return this._names.length; }\n\n    // Alias for the `on` method\n    add(...args) { return this.on(...args); }\n    bind(...args) { return this.on(...args); }\n\n    // Alias for the `off` method\n    remove(...args) { return this.off(...args); }\n    unbind(...args) { return this.off(...args); }\n\n    // Alias for the `emit` method\n    fire(...args) { return this.emit(...args); }\n    trigger(...args) { return this.emit(...args); }\n\n    // Alias for the `listeners` method\n    callbacks(...args) { return this.listeners(...args); }\n}","import { _matches, _is, keys } from \"./util\";\nimport _event from './event';\n\n// Test for passive support, based on [github.com/rafrex/detect-passive-events]\nlet passive = false, opts = {}, noop = () => { };\ntry {\n    opts = Object.defineProperty({}, \"passive\", {\n        get: () => passive = { capture: false, passive: true }\n    });\n\n    window.addEventListener(\"PassiveEventTest\", noop, opts);\n    window.removeEventListener(\"PassiveEventsTest\", noop, opts);\n} catch (e) {}\n\nlet ele;\nlet tagRE = /^\\s*<(\\w+|!)[^>]*>/;\nlet tagExpandRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig;\nexport let _qsa = (dom = document, sel) => {\n    let classes;\n    if (!_is.str(sel) && sel.length === 0) return [];\n    if (/^(#?[\\w-]+|\\.[\\w-.]+)$/.test(sel)) {\n        switch (sel.charAt(0)) {\n            case '#':\n                return [dom.getElementById(sel.substr(1))];\n            case '.':\n                classes = sel.substr(1).replace(/\\./g, ' ');\n                return [...dom.getElementsByClassName(classes)];\n            default:\n                return [...dom.getElementsByTagName(sel)];\n        }\n    }\n\n    return [...dom.querySelectorAll(sel)];\n};\n\n// Create an Element List from a HTML string\nexport let _createElem = html => {\n    let dom, container;\n    container = document.createElement('div');\n    container.innerHTML = '' + html.replace(tagExpandRE, \"<$1></$2>\");\n    dom = [].slice.call(container.childNodes);\n    dom.forEach(el => {\n        container.removeChild(el);\n    });\n\n    return dom;\n};\n\n// Element selector\nexport let _elem = (sel, ctxt) => {\n    if (_is.str(sel)) {\n        sel = sel.trim();\n        if (tagRE.test(sel)) { return _createElem(sel); }\n        else { return _qsa(ctxt, sel); }\n    } else if (_is.inst(sel, ele)) { return sel; }\n    else if (_is.arr(sel) || _is.inst(sel, NodeList))\n        { return [...sel].filter(item => _is.def(item)); }\n    else if (_is.obj(sel) || _is.el(sel)) { return [sel]; }\n    else if (_is.fn(sel)) { new ele(document).ready(sel); }\n    return [];\n};\n\n// Element Object [Based on Zepto.js]\nexport default ele = class extends _event {\n    constructor(sel = '', ctxt) {\n        super();\n        this.sel = sel; // Selector\n        this.ele = _elem(this.sel, ctxt); // Element\n\n        for (let i = 0; i < this.ele.length; i++) {\n            this[i] = this.ele[i];\n        }\n        this.length = this.ele.length;\n    }\n\n    on(evt, opts, callback) {\n        let _newEvts, _evt, delegate, $super = _event.prototype.on.bind(this);\n        if (_is.undef(evt)) { return; } // If there is no event break\n        if (_is.str(evt)) { evt = evt.split(/\\s/g); }\n        if (!_is.arr(evt) && !_is.obj(evt)) { evt = [evt]; } // Set evt to an array\n\n        _evt = (_is.obj(evt) && !_is.arr(evt) ? keys(evt) : evt);\n        _newEvts = _evt.filter(val => !(val in this._events), this);\n\n        if (_is.str(opts)) delegate = opts;\n        else callback = opts;\n\n        [].forEach.call(this, (el, i) => {\n            $super(evt, callback);\n            if (!(_newEvts.length > 0) && !_is.undef(el) && !_is.nul(el)) return;\n\n            let useCapture;\n            let _emit = evt => e => {\n                let target = _is.str(delegate) && _matches(e.target, delegate) ? e.target : el;\n                if (!_is.str(delegate) || _matches(e.target, delegate))\n                    this.emit(evt, [e, target, this, i], target);\n            };\n\n            if (/ready/.test(_newEvts)) {\n                if (!/in/.test(document.readyState)) { _emit(\"ready\") (); }\n                else if (document.addEventListener) {\n                    document.addEventListener('DOMContentLoaded', _emit(\"ready\"));\n                } else {\n                    // Support for IE\n                    document.attachEvent('onreadystatechange', e => {\n                        if (!/in/.test(document.readyState)) _emit(\"ready\") (e);\n                    });\n                }\n            } else {\n                _newEvts.forEach(val => {\n                    useCapture = /blur|focus/.test(val);\n                    el.addEventListener(val, _emit(val), val === \"scroll\" ? passive : { useCapture });\n                });\n            }\n        });\n        return this;\n    }\n};\n","import { _matches, _is, _fnval, _capital } from \"./util\";\nimport ele, { _qsa, _elem, _createElem } from './ele';\n\n// Quick access to a new ele object\nexport let el = (sel, ctxt) => {\n    return _is.inst(sel, ele) && !_is.usable(ctxt) ? sel : new ele(sel, ctxt);\n};\n\n// Select specific element at an index of the ele object\nexport let get = (_el, idx) => {\n    _el = el(_el);\n    return _is.undef(idx) ? [].slice.call(_el) : _el[idx >= 0 ? idx : idx + _el.length];\n};\nexport let nth = get; // An alias of get\nexport let toArray = val => (_is.inst(val, ele) ? get(val) : val); // Convert ele objects to arrays\nexport let indexOf = (_el, val) => [].indexOf.call(el(_el), val); // Array.indexOf for the ele object\n\n// Array.slice designed to work with Elements\nexport let slice = (_el, ...args) => el([].slice.apply(el(_el), args));\n\n// Create a wrapper ele object for an element at a certain index\nexport let eq = (_el, idx) => {\n    return idx === -1 ? slice(_el, idx) : slice(_el, idx, +idx + 1);\n};\n\n// Select the first element in ele object\nexport let first = _el => {\n    let el = get(_el, 0);\n    return el && !_is.obj(el) ? el : new ele(el);\n};\n\n// Select the last element in ele object\nexport let last = _el => {\n    let el = get(_el, -1);\n    return el && !_is.obj(el) ? el : new ele(el);\n};\n\n// Support the Element Object as an Array\nlet _concat = function (...args) {\n    [].map.call(args, val => toArray(val)); // Transform Elements to Arrays\n    return [].concat(...args);\n};\n\n// Map objects and remove undefined/null values\nlet _map = (obj, fn, ctxt) => {\n    let arr = [].map.call(obj, fn, ctxt)\n        .filter(item => _is.usable(item));\n\n    // Creates a flat Array of Objects\n    return (arr.length > 0 ? _concat(...arr) : arr);\n};\n\n// Added support for element mapping\nexport let map = (_el, fn) => {\n    _el = el(_el);\n    return el(_map(_el, (el, i) => fn.call(el, el, i)));\n};\n\n// Functions the same way Array.forEach does\nexport let forEach = (_el, fn, ctxt) => {\n    _el = el(_el);\n    [].forEach.call(_el, function (el, idx)\n        { fn.call(ctxt, el, idx); }, ctxt);\n    return _el;\n};\n\n/* Similar to forEach, however, the context of the iterator is set and\n   it allows the iterators return value to stop the iteration just like Array.every */\nexport let each = (_el, fn) => {\n    _el = el(_el);\n    [].every.call(_el, function (el, idx)\n        { return fn.call(el, el, idx) !== false; });\n    return _el;\n};\n\n// Quickly filter nodes by a selector\nexport let filter = (_el, sel) => {\n    _el = el(_el);\n    if (_is.undef(sel)) return _el;\n    return el([].filter.call(_el, _is.fn(sel) ? sel : ele => _matches(ele, sel), _el));\n};\n\n// Check if the parent node contains the given DOM node. Returns false if both are the same node.\nlet _contains = (parent, node) => {\n    if (parent.contains) return parent !== node && parent.contains(node);\n    while (node && (node = node.parentNode))\n        if (node === parent) return true;\n    return false;\n};\n\n// Find an element that matches a selector in a ele object\nexport let find = (_el, sel) => {\n    let result;\n    _el = el(_el);\n    if (!sel) result = el();\n    else if (_is.obj(sel)) {\n        result = filter(sel, el => {\n            return [].some.call(_el, parent => _contains(parent, el));\n        });\n    } else if (_el.length === 1) { result = el(_qsa(first(_el), sel)); }\n    else { result = map(_el, el => _qsa(el, sel)); }\n    return result;\n};\n\n// Check to see if a ele object has a certain element\nexport let has = (_el, sel) => {\n    return filter(_el, el => {\n        return _is.obj(sel) ? _contains(el, sel) : find(el, sel).length;\n    });\n};\n\n// Traverse upwards from the current element to find the first element that matches the selector.\nexport let closest = (_el, sel, ctxt) => {\n    let list = _is.obj(sel) && el(sel);\n    _el = el(el);\n    return el(\n        [].reduce.call(_el, (acc, $el) => {\n            do {\n                if (list ? indexOf(list, $el) >= 0 : _matches($el, sel)) break;\n                $el = $el !== ctxt && !_is.doc($el) && $el.parentNode;\n            } while ($el !== null && $el.nodeType === 1);\n            if ($el && acc.indexOf($el) < 0) acc.push($el);\n            return acc;\n        }, [])\n    );\n};\n\n// Select the parents of an element\nexport let parents = (_el, sel) => {\n    let ancestors = [], nodes = el(_el);\n    while (nodes.length > 0) {\n        nodes = map(nodes, el => {\n            if ((el = el.parentNode) && !_is.doc(el) && ancestors.indexOf(el) < 0) {\n                ancestors.push(el);\n                return el;\n            }\n        });\n    }\n    return filter(ancestors, sel);\n};\n\n// `pluck` based on underscore.js, select a specific property from the ele object\nexport let pluck = (_el, prop) => map(_el, el => el[prop]);\n\n// Select all the different values in an Array, based on underscorejs\nlet _uniq = arr => {\n    return [].filter.call(arr, (val, idx) => arr.indexOf(val) === idx);\n};\n\n// Get immediate parents of each element in the collection. If CSS selector is given, filter results to include only ones matching the selector.\nexport let parent = (_el, sel) => {\n    return filter(_uniq(pluck(_el, 'parentNode')), sel);\n};\n\n// Select all children of an element\nlet _children = val => {\n    return 'children' in val ? [].slice.call(val.children) :\n        _map(val.childNodes, node => {\n            if (node.nodeType === 1) return node;\n        });\n};\n\n// Get immediate children of each element in the current collection. If selector is given, filter the results to only include ones matching the CSS selector.\nexport let children = (_el, sel) => {\n    return filter(map(_el, el => _children(el)), sel);\n};\n\n// Get the children of each element in the collection, including text and comment nodes.\nexport let contents = _el => {\n    return map(_el, el => el.contentDocument || [].slice.call(el.childNodes));\n};\n\n// Get all sibling nodes of each element in the collection. If CSS selector is specified, filter the results to contain only elements that match the selector.\nexport let siblings = (_el, sel) => {\n    return filter(map(_el, el =>\n        [].filter.call(\n            _children(el.parentNode),\n            child => (child !== el)\n        )\n    ), sel);\n};\n\n/* - DOM Manipulation - */\n// Remove elements in the current collection from their parent nodes, effectively detaching them from the DOM.\nexport let remove = _el => {\n    return each(_el, el => {\n        if (_is.def(el.parentNode));\n            el.parentNode.removeChild(el);\n    });\n};\n\n// Traverse DOM Depth First\nlet traverseDF = (_node, fn) => {\n    let recurse;\n    // This is a recurse and immediately-invoking function\n    recurse = node => { // Step 2\n        node.childNodes && [...node.childNodes].forEach(recurse, node); // Step 3\n        fn.call(node, node); // Step 4\n    };\n    recurse(_node); // Step 1\n};\n\n// Generate the `after`, `prepend`, `before`, `append`, `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\nlet _insert = (pos, _target) => {\n    // inside => prepend, append\n    let inside = pos === \"inside\";\n    return (_el, ...args) => {\n        // Arguments can be nodes, arrays of nodes, Element objects and HTML strings\n        _el = el(el);\n        let clone = _el.length > 1;\n        let nodes = _map(args, arg => {\n            if (_is.arr(arg)) {\n                return arg.reduce((acc, el) => {\n                    if (_is.def(el.nodeType)) acc.push(el);\n                    else if (_is.inst(el, ele)) acc = acc.concat(toArray(el));\n                    else if (_is.str(el)) acc = acc.concat(_createElem(el));\n                    return acc;\n                }, []);\n            }\n\n            return _is.obj(arg) || _is.nul(arg) ? arg : _createElem(arg);\n        });\n\n        return each(_el, target => {\n            let parent = inside ? target : target.parentNode;\n            let parentInDoc = _contains(document.documentElement, parent);\n            let next = target.nextSibling, first = target.firstChild;\n\n            // Convert all methods to a \"before\" operation\n            target = { next, first, target, null: null } [_target];\n            nodes.forEach(node => {\n                if (clone) node = node.cloneNode(true);\n                else if (!parent) return remove(node);\n                parent.insertBefore(node, target);\n\n                if (parentInDoc) {\n                    traverseDF(node, function (el) {\n                        if (!_is.nul(el.nodeName) && el.nodeName.toUpperCase() === 'SCRIPT' &&\n                            (!el.type || el.type === 'text/javascript') && !el.src) {\n                            let target = el.ownerDocument ? el.ownerDocument.defaultView : window;\n                            target.eval.call(target, el.innerHTML);\n                        }\n                    });\n                }\n            });\n        });\n    };\n};\n\n// after    => insertAfter, prepend  => prependTo\n// before   => insertBefore, append   => appendTo\nlet _specificInsert = fn => {\n    return (_el, html) => {\n        _el = el(_el);\n        fn(html, _el);\n        return _el;\n    };\n};\n\nexport let after = _insert(\"outside\", \"next\");\nexport let prepend = _insert(\"inside\", \"first\");\nexport let before = _insert(\"outside\", \"target\");\nexport let append = _insert(\"inside\", \"null\");\n\nexport let insertAfter = _specificInsert(after);\nexport let insertBefore = _specificInsert(before);\nexport let appendTo = _specificInsert(append);\nexport let prependTo = _specificInsert(prepend);\n\n// Replace each element in the collectionboth its contents and the element itselfwith the new content. Content can be of any type described in before.\nexport let replaceWith = (_el, content) => remove(before(_el, content));\nexport let clone = _el => map(_el, el => el.cloneNode(true)); // Duplicate all elements in the collection via deep clone.\n\n// CSS properties that use unitless numbers\nlet _cssNumber = [\"column-count\", \"columns\", \"font-weight\", \"line-height\", \"opacity\", \"z-index\", \"zoom\"];\n\n// Decide if the value deserves px at the\nlet _maybeAddPx = (name, val) => {\n    return _is.num(+val) && !_cssNumber.includes(name) ? `${val}px` : val;\n};\n\n// Read or set CSS properties on DOM elements.\nexport let style = (_el, ...args) => {\n    let [prop, val] = args, css = '', key;\n    if (args.length < 2) {\n        let el = first(_el);\n        if (!el) return;\n        if (_is.str(prop)) {\n            return el.style[prop] || window.getComputedStyle(el, '').getPropertyValue(prop);\n        } else if (_is.arr(prop)) {\n            let props = {};\n            let computedStyle = window.getComputedStyle(el, '');\n            prop.forEach(_prop => {\n                props[_prop] = (el.style[_prop] || computedStyle.getPropertyValue(_prop));\n            });\n            return props;\n        }\n    }\n\n    if (_is.str(prop)) {\n        if (!val && val !== 0) {\n            each(_el, el => { el.style.removeProperty(prop); });\n        } else {\n            css = prop + \":\" + _maybeAddPx(prop, val);\n        }\n    } else {\n        for (key in prop) {\n            if (!prop[key] && prop[key] !== 0) {\n                each(_el, el => { el.style.removeProperty(key); });\n            } else {\n                css += key + ':' + _maybeAddPx(key, prop[key]) + ';';\n            }\n        }\n    }\n\n    return each(_el, el => { el.style.cssText += ';' + css; });\n};\n\n// Method for creating size methods\nlet _size = sz => {\n    let prop = _capital(sz);\n    return (_el, value) => {\n        let _offset, el = first(_el);\n        if (_is.undef(value)) {\n            if (_is.win(el)) {\n                return el[`inner${prop}`];\n            } else if (_is.doc(el)) {\n                return el.documentElement[`scroll${prop}`];\n            } else { return (_offset = offset(_el)) && _offset[sz]; }\n        } else {\n            return each(_el, ($el, idx) => {\n                style($el, sz, _fnval(value, [idx, el[sz]()], $el));\n            });\n        }\n    };\n};\n\n// Generate the `width` and `height` methods\nexport let width = _size(\"width\");\nexport let height = _size(\"height\");\n\n// Show/hide an element\nexport let show = _el => { return style(_el, \"display\", \"\"); };\nexport let hide = _el => { return style(_el, \"display\", \"none\"); };\n\n// Toggle between showing and hiding each of element in the ele object, based on whether the first element is visible or not.\nexport let toggle = (_el, opt) => {\n    return each(_el, el => {\n        let _el = _elem(el);\n        let _opt = opt || style(_el, \"display\") === \"none\";\n        _opt ? show(_el) : hide(_el)\n    });\n};\n\n// Select element siblings based on selector\nexport let prev = (_el, sel) => filter(pluck(_el, 'previousElementSibling'), sel || '*');\nexport let next = (_el, sel) => filter(pluck(_el, 'nextElementSibling'), sel || '*');\n\n// Empty the value of an element in the ele object\nexport let empty = _el => each(_el, el => { el.innerHTML = ''; });\n\n// Get or set HTML contents of elements in the collection. When no content given, returns innerHTML of the first element.\nexport let html = (_el, ...args) => {\n    let [html] = args;\n    _el = el(_el);\n    return args.length ?\n        each(_el, (el, idx) => {\n            let originHTML = el.innerHTML;\n            append(empty(el), _fnval(html, [idx, originHTML], el));\n        }) : (_el.length ? first(_el).innerHTML : null);\n};\n\nexport let text = (_el, ...args) => {\n    let [text] = args;\n    _el = el(_el);\n    return args.length ?\n        each(_el, (el, idx) => {\n            let newText = _fnval(text, [idx, el.textContent], el);\n            el.textContent = _is.nul(newText) ? '' : `${newText}`;\n        }) : (_el.length ? pluck(_el, 'textContent').join(\"\") : null);\n};\n\n// Quickly set the value of an attribute or remove the attribute completely from a node\nlet _setAttr = (node, name, value) => value === null ? node.removeAttribute(name) : node.setAttribute(name, value);\n\n// Set the attribute of elements in the ele object\nexport let attr = (_el, name, val) => {\n    let result;\n    _el = el(_el);\n    if (_is.str(name) && _is.undef(val)) {\n        result = _el.length && first(_el).nodeType === 1 &&\n            first(_el).getAttribute(name);\n        return !_is.nul(result) ? result : undefined;\n    } else {\n        return each(_el, (el, idx) => {\n            if (el.nodeType !== 1) return;\n            if (_is.arr(name)) {\n                for (let i in name)\n                    _setAttr(el, i, name[i]);\n            } else {\n                _setAttr(el, name, _fnval(val, [idx, el.getAttribute(name)], el));\n            }\n        });\n    }\n};\n\n// Remove an attribute from all elements in the ele object\nexport let removeAttr = (_el, name) => {\n    return each(_el, el => {\n        el.nodeType === 1 && name.split(' ')\n            .forEach(attr => { _setAttr(el, attr); });\n    });\n};\n\n// Transform string values to the proper type of value eg. \"12\" = 12, \"[12, 'xyz']\" = [12, 'xyz']\nlet _valfix = value => {\n    let validTypes = /^true|false|null|undefined|\\d+$/;\n    let _fn = v => Function(`\"use strict\"; return ${v};`) ();\n    let objectType = /^[[{]([\\s\\S]+)?[\\]}]$/;\n    try {\n        return validTypes.test(value) ? _fn(value) :\n            objectType.test(value) ? JSON.parse(value.replace(/'/g, \"\\\"\")) : value;\n    } catch (e) { return value; }\n};\n\n// Read or write data-* DOM attributes. Behaves like attr, but prepends data- to the attribute name.\nexport let data = (_el, name, value) => {\n    let attrName = `data-${name}`.toLowerCase();\n    let data = _is.def(value) ? attr(_el, attrName, value) : attr(_el, attrName);\n    return data !== null ? _valfix(data) : undefined;\n};\n\n/* Get or set the value of form controls. When no value is given, return the value of the first element.\n   For <select multiple>, an array of values is returend. When a value is given, set all elements to this value. */\nexport let val = (_el, value, ...args) => {\n    _el = el(_el);\n    if (args.length) {\n        if (_is.nul(value)) value = \"\";\n        return each(_el, (el, idx) => {\n            el.value = _fnval(value, [idx, el.value], el);\n        });\n    } else {\n        _el = first(_el);\n        return _el && (_el.multiple ?\n            pluck(filter(find(_el, 'option'), el => el.selected), 'value') :\n            _el.value);\n    }\n};\n\n// Get position of the element in the document. Returns an object with properties: top, left, width and height.\nexport let offset = (_el, coords) => {\n    let obj;\n    _el = el(_el);\n    if (coords) {\n        return each(_el, (el, idx) => {\n            let $this = new ele(el);\n            let _coords = _fnval(coords, [idx, offset($this)], el);\n            let parentOffset = offset(offsetParent($this));\n            let props = {\n                top: _coords.top - parentOffset.top,\n                left: _coords.left - parentOffset.left\n            };\n\n            if (style($this, 'position') === 'static') props.position = 'relative';\n            style($this, props);\n        })\n    }\n\n    if (!_el.length) return null;\n    if (document.documentElement !== first(_el) && !_contains(document.documentElement, first(_el)))\n        return { top: 0, left: 0 };\n\n    obj = first(_el).getBoundingClientRect();\n    return {\n        left: obj.left + window.pageXOffset,\n        top: obj.top + window.pageYOffset,\n        width: Math.round(obj.width),\n        height: Math.round(obj.height)\n    };\n};\n\n// Get the position of an element in the ele object collection. When no element is given, returns position of the current element among its siblings. When an element is given, returns its position in the current collection. Returns -1 if not found.\nexport let index = (_el, el) => {\n    _el = new ele(_el);\n    return el ? indexOf(_el, first(el)) : indexOf(children(parent(_el)), first(_el));\n};\n\n// Class name cache\nlet classcache = {};\n\n// Class name RegExp\nlet _classRE = name => {\n    return name in classcache ? classcache[name] :\n        (classcache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'));\n};\n\n// Get the class name for an element\nlet getclass = (node, value) => {\n    let name = node.className || '';\n    let svg  = name && !_is.undef(name.baseVal);\n\n    if (_is.undef(value)) return svg ? name.baseVal : name;\n    svg ? (name.baseVal = value) : (node.className = value);\n};\n\n// Check if any elements in the collection have the specified class.\nexport let hasClass = (_el, name) => {\n    if (!name) return false;\n    return [].some.call(el(_el), el => {\n        return _classRE(name).test(getclass(el));\n    });\n};\n\n// Add class name to each of the elements in the collection. Multiple class names can be given in a space-separated string.\nexport let addClass = (_el, name) => {\n    _el = el(_el);\n    if (!name) return _el;\n    return each(_el, (el, idx) => {\n        if (!('className' in el)) return;\n\n        let classList = [], cls = getclass(el);\n        _fnval(name, [idx, cls], el).split(/\\s+/g).forEach(_name => {\n            if (!hasClass(el, _name)) classList.push(_name);\n        });\n\n        classList.length && getclass(el, cls + (cls ? \" \" : \"\") + classList.join(\" \"));\n    });\n};\n\n// Remove the specified class name from all elements in the collection. When the class name isnt given, remove all class names. Multiple class names can be given in a space-separated string.\nexport let removeClass = (_el, name) => {\n    return each(_el, function (el, idx) {\n        if (!('className' in el)) return;\n        if (_is.undef(name)) return getclass(el, '');\n\n        let classList = getclass(el);\n        _fnval(name, [idx, classList], el).split(/\\s+/g).forEach(_name => {\n            classList = classList.replace(_classRE(_name), \" \");\n        });\n\n        getclass(el, classList.trim());\n    });\n};\n\n// Toggle given class names (space-separated) in each element in the collection. The class name is removed if present on an element; otherwise its added.\nexport let toggleClass = (_el, name, when) => {\n    _el = el(_el);\n    if (!name) return _el;\n    return each(_el, function (el, idx) {\n        let $this = new ele(el);\n        _fnval(name, [idx, getclass(el)], el).split(/\\s+/g)\n        .forEach(_name => {\n            (_is.undef(when) ? !hasClass($this, _name) : when) ?\n            addClass($this, _name) : removeClass($this, _name);\n        });\n    });\n};\n\n// Find the first ancestor element that is positioned, meaning its CSS position value is \"relative\", \"absolute\" or \"fixed\".\nexport let offsetParent = _el => {\n    return map(_el, el => {\n        let parent = el.offsetParent || document.body;\n        while (parent && !/^(?:body|html)$/i.test(parent.nodeName) &&\n            style(parent, \"position\") === \"static\") {\n            parent = parent.offsetParent;\n        }\n        return parent;\n    });\n};\n\n// Get the position of the first element in the collection, relative to the offsetParent. This information is useful when absolutely positioning an element to appear aligned with another.\nexport let position = _el => {\n    _el = el(_el);\n    if (!_el.length) return;\n\n    let elem = first(_el),\n        _offsetParent = offsetParent(_el),\n        _offset = offset(_el),\n        parentOffset = /^(?:body|html)$/i.test(_offsetParent[0].nodeName) ? { top: 0, left: 0 } : offset(_offsetParent);\n\n    _offset.top -= parseFloat(style(elem, 'margin-top')) || 0;\n    _offset.left -= parseFloat(style(elem, 'margin-left')) || 0;\n\n    parentOffset.top += parseFloat(style(_offsetParent[0], 'border-top-width')) || 0;\n    parentOffset.left += parseFloat(style(_offsetParent[0], 'border-left-width')) || 0;\n\n    return {\n        top: _offset.top - parentOffset.top,\n        left: _offset.left - parentOffset.left\n    }\n};\n\n// Gets or sets how many pixels were scrolled down so far on window or scrollable element on the page.\nexport let scrollTop = (_el, val) => {\n    _el = el(_el);\n    if (!_el.length) return;\n\n    let hasScroll = 'scrollTop' in first(_el);\n    if (_is.undef(val)) return first(_el)[hasScroll ? \"scrollTop\" : \"pageYOffset\"];\n    return each(_el, el => {\n        hasScroll ? (el.scrollTop = val) : el.scrollTo(el.scrollX, val);\n    });\n};\n\n// Gets or sets how many pixels were scrolled right so far on window or scrollable element on the page.\nexport let scrollLeft = (_el, val) => {\n    _el = el(_el);\n    if (!_el.length) return;\n\n    let hasScroll = 'scrollLeft' in first(_el);\n    if (_is.undef(val)) return first(_el)[hasScroll ? \"scrollLeft\" : \"pageXOffset\"];\n    return each(_el, el => {\n        hasScroll ? (el.scrollLeft = val) : el.scrollTo(val, el.scrollY);\n    });\n};\n\n// Generate shortforms for events eg. onclick(), onhover(), etc...\nexport let { onready, onload, onblur, onfocus, onfocusin, onfocusout, onresize, onclick, onscroll, ondblclick, onmousedown, onmouseup, onmousemove, onmouseover, onmouseout, onmouseenter, onmouseleave, onchange, onselect, onsubmit, onkeydown, onkeypress, onkeyup, oncontextmenu } = `ready load blur focus focusin focusout resize click scroll dblclick mousedown\n    mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit\n    keydown keypress keyup contextmenu`.split(/[\\s\\n]+/g)\n.reduce((acc, name) => {\n    // Handle event binding\n    acc[`on${name}`] = (_el, ...args) => el(_el).on(name, ...args);\n    return acc;\n}, {\n    onhover: (_el, fnOver, fnOut) =>\n        el(_el).on(\"mouseenter\", fnOver)\n               .on(\"mouseleave\", fnOut || fnOver)\n});\n\nexport default el;"]}